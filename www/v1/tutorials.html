<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>DynaMix: Tutorials</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynaMix
   &#160;<span id="projectnumber">1.3.7</span>
   </div>
   <div id="projectbrief">A new take on polymorphism in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorials.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tutorials </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#messages">Messages </a></li>
<li class="level1"><a href="#message_bids">Message bids </a></li>
<li class="level1"><a href="#obj_mutation">Object mutation </a></li>
<li class="level1"><a href="#mut_rules">Mutation rules </a></li>
<li class="level1"><a href="#mult_combinators">Multicast result combinators </a></li>
<li class="level1"><a href="#tips_tricks">Tips and tricks </a><ul><li class="level2"><a href="#common_mixin_parent">Mixins with a common parent </a></li>
</ul>
</li>
<li class="level1"><a href="#common_problems">Common problems and solutions </a><ul><li class="level2"><a href="#compiler_errors">Compiler errors </a></li>
<li class="level2"><a href="#linker_errors">Linker errors </a></li>
<li class="level2"><a href="#runtime_errors">Runtime errors </a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="messages"></a>
Messages </h1>
<p>(For the complete, working source of this example see <a href="https://github.com/iboB/dynamix/blob/master/tutorial/messages.cpp">messages.cpp</a>)</p>
<p>For this tutorial we'll look at a simplified piece of code from an imaginary game. First let's define the mixin classes that we're going to use.</p>
<p>There's a mixin that's a part from every object of our game. The one that gives them a unique id. We'll also define a method, called <code>trace</code> that will display information about the mixin in a stream.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>has_id</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> set_id(<span class="keywordtype">int</span> <span class="keywordtype">id</span>) { _id = id; }</div><div class="line">    <span class="keywordtype">int</span> id()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _id; }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> trace(ostream&amp; out) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">int</span> _id;</div><div class="line">};</div></div><!-- fragment --><p> Next we'll define a class for an animated model. We could have other types of models in the game, but for this tutorial there's no need to define anything more.</p>
<p>The mixin offers us a way to set a mesh and two ways to set an animation. It has a render method and, again the trace method, to display info about this mixin.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>animated_model</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> set_mesh(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; mesh);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> set_animation(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; animation);</div><div class="line">    <span class="keywordtype">void</span> set_animation(<span class="keywordtype">int</span> anim_id);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> render() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> trace(ostream&amp; out) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">string</span> _mesh;</div><div class="line">    <span class="keywordtype">string</span> _animation;</div><div class="line">};</div></div><!-- fragment --><p> Now we'll define three types of mixins that will give us artificial intelligence logic for different occasions. They all share a method called <code>think</code> for the AI, and the familiar trace method.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>enemy_ai</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> think();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> trace(ostream&amp; out) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ally_ai</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> think();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> trace(ostream&amp; out) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>stunned_ai</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> think();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> trace(ostream&amp; out) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p> Now it's time to declare the messages our mixins will use. We have some methods in our classes for which there won't be any messages, since those methods aren't polymorphic. They're unique for their specific classes so it's absolutely adequate to call them by <code>object.get&lt;mixin&gt;()-&gt;method(...)</code>.</p>
<p>So, let's start with the simplest case. The one we already used in the <a href="basic.html">basic usage example</a>.</p>
<p>The declaration syntax is the familiar macro <code>DYNAMIX_MESSAGE_|N|</code>, where <code>|N|</code> stands for the number of arguments the message has. The macro's arguments are coma separated: return value, message/method name, argument 1 type, argument 1 name, argument 2 type, argument 2 name, etc etc.</p>
<p>This simple case is covered by the messages <code>think</code> and <code>set_mesh</code>. Although set_mesh is a message that can be handled by a single class in our example, in an actual product there would be other types of "model" mixins, which would make it polymorphic. That's why we're making it a message instead of a method to be called by <code>object.get&lt;animated_model&gt;()-&gt;set_mesh(somemesh)</code></p>
<div class="fragment"><div class="line">DYNAMIX_MESSAGE_0(<span class="keywordtype">void</span>, think);</div><div class="line">DYNAMIX_MESSAGE_1(<span class="keywordtype">void</span>, set_mesh, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp;, mesh);</div></div><!-- fragment --><p> Now it may seem that <code>render</code> is also a pretty simple example of a message, but there's a small difference. It's supposed to be handled by const methods. This makes it a const message and as such it has a different declaration macro &ndash; the same as before but with <code>CONST</code> added to it:</p>
<div class="fragment"><div class="line">DYNAMIX_CONST_MESSAGE_0(<span class="keywordtype">void</span>, render);</div></div><!-- fragment --><p> Lets see the <code>trace</code> method, that's present in all of our classes. If we declare a message for it in the way we talked above, only one of the mixins within an object will be able to handle it. But when we <code>trace</code> an object's info, we obviously would like to have the info for all of its mixins. For cases like this: where more than one of the mixins in an object is supposed to handle a message, DynaMix introduces <em>multicast</em> messages. You declare those by adding <code>MULTICAST</code> to the macro (before <code>MESSAGE</code> but after <code>CONST</code> if it's a const one)</p>
<div class="fragment"><div class="line">DYNAMIX_CONST_MULTICAST_MESSAGE_1(<span class="keywordtype">void</span>, trace, ostream&amp;, out);</div></div><!-- fragment --><p> The last type of message there is meant for overloaded methods. For these we need message overloads.</p>
<p>A message overload will require you to think of a special name, that's used to refer to that message, different from the name of the method. Don't worry. The stand-alone function that's generated for the message call itself will have the appropriate name (the method's name).</p>
<p>The macro used for message overloads is the same as before with <code>OVERLOAD</code> at the end. The other difference is that its first argument should be the custom name for the message (followed by the type, method name, and method/message arguments like before).</p>
<p>In our case <code>set_animation</code> has two overloads:</p>
<div class="fragment"><div class="line">DYNAMIX_MESSAGE_1_OVERLOAD(set_anim_by_name, <span class="keywordtype">void</span>, set_animation, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp;, animation);</div><div class="line">DYNAMIX_MESSAGE_1_OVERLOAD(set_anim_by_id, <span class="keywordtype">void</span>, set_animation, <span class="keywordtype">int</span>, anim_id);</div></div><!-- fragment --><p> As you might have guessed, any message could be defined as a message overload and indeed in the case where there are no overloads <code>DYNAMIX_MESSAGE_N(ret, message_name, ...)</code> will just expand to <code>DYNAMIX_MESSAGE_N_OVERLOAD(message_name, ret, message_name, ...)</code></p>
<p>So, now that we've declared all our messages it's time to define them.</p>
<p>The macro used for defining a message is always the same, regardless of the message's constness, mechanism (multicast/unicast), or overload. It has a single argument &ndash; the message's name.</p>
<div class="fragment"><div class="line"><a class="code" href="message__macros_8hpp.html#a4ea78051262bb047d5127da21a2e7af0">DYNAMIX_DEFINE_MESSAGE</a>(think);</div><div class="line"><a class="code" href="message__macros_8hpp.html#a4ea78051262bb047d5127da21a2e7af0">DYNAMIX_DEFINE_MESSAGE</a>(set_mesh);</div><div class="line"><a class="code" href="message__macros_8hpp.html#a4ea78051262bb047d5127da21a2e7af0">DYNAMIX_DEFINE_MESSAGE</a>(trace);</div></div><!-- fragment --><p> For the overloads we should use our custom name:</p>
<div class="fragment"><div class="line"><a class="code" href="message__macros_8hpp.html#a4ea78051262bb047d5127da21a2e7af0">DYNAMIX_DEFINE_MESSAGE</a>(set_anim_by_name);</div><div class="line"><a class="code" href="message__macros_8hpp.html#a4ea78051262bb047d5127da21a2e7af0">DYNAMIX_DEFINE_MESSAGE</a>(set_anim_by_id);</div></div><!-- fragment --><p> Great! Now that we have our messages it's time to define the classes from above as mixins.</p>
<p>Normally if our program is spread across several files, you should use <code>DYNAMIX_DECLARE_MIXIN</code> to declare that those classes are mixins, but since our program is in a single file, it can be omitted. All of its functionality is also in <code>DYNAMIX_DEFINE_MIXIN</code>.</p>
<p>We met the <code>DYNAMIX_DEFINE_MIXIN</code> macro from the basic example. It has two arguments &ndash; the mixin/class name and its feature list. The feature list is a ampersand separated list of symbols that represent the mixin's features. It can contain many things, but for now we'll focus on messages &ndash; the ones this mixin is supposed to handle.</p>
<p>The special thing here is that in order to distinguish the stand-alone function that's generated to make message calls from the message, the library defines a special symbol for each message. This symbol is used in the mixin feature list and when checking whether a mixin implements a message. The symbol is the message name postfixed with <code>_msg</code>.</p>
<p>Let's define three of our simple mixins along with their feature (message) lists:</p>
<div class="fragment"><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(enemy_ai, think_msg &amp; trace_msg);</div><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(ally_ai, think_msg &amp; trace_msg);</div><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(animated_model,</div><div class="line">    trace_msg &amp; set_mesh_msg &amp; set_anim_by_id_msg &amp; set_anim_by_name_msg &amp; render_msg);</div></div><!-- fragment --><p> The reason we left out <code>has_id</code> and <code>stunned_ai</code> is because we'd like to do something special with their message lists.</p>
<p>First, about <code>has_id</code>. What we'd like to do is display its info first, because the object id is usually the first thing you need about an object. So in order to achieve this, the notion of message priority is introduced. Each message in a mixin gets a priority of 0 by default. For multicast messages, like <code>trace</code>, the priority will affect the order in which they're executed. The higher priority a multicast message has in a mixin, the earlier it will be executed. So if we set the priority of <code>trace</code> in <code>has_id</code> to something greater than zero, we'll have a guarantee that when the object info is displayed, its id will come first.</p>
<div class="fragment"><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(has_id, priority(1, trace_msg));</div></div><!-- fragment --><p> For unicast messages the priority determines which of the potentially many mixin candidates will handle the message. Again, mixins with higher priority for a message are considered better candidates.</p>
<p>So if we set the priority of <code>think</code> in <code>stunned_ai</code> to something greater than zero, then adding this mixin to an object that already has a think message (like objects with <code>enemy_ai</code> or <code>ally_ai</code>), will hide it previous implementation and override it with the one from <code>stunned_ai</code>. If we remove the mixin, the previous implementation will be exposed and will resume handling the <code>think</code> calls.</p>
<p>Also we'll consider <code>stunned_ai</code> as a relatively uninteresting mixin, and set the priority of <code>trace</code> to -1, and make its info be displayed last (if at all available)</p>
<div class="fragment"><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(stunned_ai, priority(1, think_msg) &amp; priority(-1, trace_msg));</div></div><!-- fragment --><p> We're now ready to start using our mixins and messages in the simplified game.</p>
<p>Let's start by creating two objects - an enemy and an ally to the hypothetical main character. We'll give them some irrelevant id-s and meshes.</p>
<div class="fragment"><div class="line"><a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a> enemy; <span class="comment">// just an empty dynamix::object</span></div><div class="line"></div><div class="line"><a class="code" href="classdynamix_1_1single__object__mutator.html">dynamix::mutate</a>(enemy)</div><div class="line">    .add&lt;has_id&gt;()</div><div class="line">    .add&lt;animated_model&gt;()</div><div class="line">    .add&lt;enemy_ai&gt;();</div><div class="line"></div><div class="line">enemy.<a class="code" href="classdynamix_1_1object.html#a3ac87d5fed5273a72e40cff82fe0a2c5">get</a>&lt;has_id&gt;()-&gt;set_id(1);</div><div class="line">set_mesh(enemy, <span class="stringliteral">&quot;spider.mesh&quot;</span>);</div><div class="line"></div><div class="line">trace(enemy, cout); <span class="comment">// trace enemy data</span></div><div class="line"></div><div class="line"><a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a> ally;</div><div class="line"></div><div class="line"><a class="code" href="classdynamix_1_1single__object__mutator.html">dynamix::mutate</a>(ally)</div><div class="line">    .add&lt;has_id&gt;()</div><div class="line">    .add&lt;animated_model&gt;()</div><div class="line">    .add&lt;ally_ai&gt;();</div><div class="line"></div><div class="line">ally.<a class="code" href="classdynamix_1_1object.html#a3ac87d5fed5273a72e40cff82fe0a2c5">get</a>&lt;has_id&gt;()-&gt;set_id(5);</div><div class="line">set_mesh(ally, <span class="stringliteral">&quot;dog.mesh&quot;</span>);</div><div class="line"></div><div class="line">trace(ally, cout); <span class="comment">// trace ally data</span></div></div><!-- fragment --><p> Both calls to <code>trace</code> from above will display info about the newly constructed objects in the console.</p>
<div class="fragment"><div class="line">think(enemy); <span class="comment">// doing enemy stuff</span></div><div class="line">think(ally); <span class="comment">// doing friendly stuff</span></div><div class="line"></div><div class="line">render(enemy); <span class="comment">// drawing a hostile enemy</span></div><div class="line">render(ally); <span class="comment">// drawing a friendly ally</span></div></div><!-- fragment --><p> Now lets try stunning our enemy. We'll just add the <code>stunned_ai</code> mixin and, because of its special <code>think</code> priority, the calls to <code>think</code> from then on will be handled by it.</p>
<div class="fragment"><div class="line"><a class="code" href="classdynamix_1_1single__object__mutator.html">dynamix::mutate</a>(enemy).add&lt;stunned_ai&gt;();</div><div class="line">think(enemy); <span class="comment">// don&#39;t do hostile stuff, because you&#39;re stunned</span></div><div class="line">render(enemy); <span class="comment">// drawing a stunned enemy</span></div></div><!-- fragment --><p> Now let's remove the stun effect from our enemy, by simply removing the <code>stunned_ai</code> mixin from the object. The handling of <code>think</code> by <code>enemy_ai</code> will resume as before.</p>
<div class="fragment"><div class="line"><a class="code" href="classdynamix_1_1single__object__mutator.html">dynamix::mutate</a>(enemy).remove&lt;stunned_ai&gt;();</div><div class="line">think(enemy); <span class="comment">// again do hostile stuff</span></div><div class="line">render(enemy); <span class="comment">// drawing a hostile enemy</span></div></div><!-- fragment --><p> Finally, in this tutorial we'll examine another type of object. An utility one. It has no rendering but is still a part of the scene. Let's say it's a spatial tigger of some sort:</p>
<div class="fragment"><div class="line"><a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a> trigger;</div><div class="line"></div><div class="line"><a class="code" href="classdynamix_1_1single__object__mutator.html">dynamix::mutate</a>(trigger)</div><div class="line">    .add&lt;has_id&gt;()</div><div class="line">    <span class="comment">// ...also other mixins not relevant for this tutorial</span></div><div class="line">    ;</div></div><!-- fragment --><p> Now what would happen if we call <code>render</code> for this object. You might know that in such case an exception will be thrown: <code><a class="el" href="classdynamix_1_1bad__message__call.html" title="Thrown when a message is called on a object that doesn&#39;t implement it. ">dynamix::bad_message_call</a></code>. To prevent this from happening, we typically take special precautions that messages are never called for objects that don't implement them. For example we might maintain a list of all objects that do implement <code>render</code> only loop through it when we render the scene. This, among others, is a perfectly valid solution, but let's say that in our particular case the non-renderable objects are so few, that we would much rather pay the price of an empty message call than the one for maintaing a list of all renderable objects.</p>
<p>A possible, and still valid, solution is to add a mixin to all non-renderable objects which implements <code>render</code> with something default (in our case nothing), but another one is to use default message implementations.</p>
<p>You might have noticed that the <code>render</code> message wasn't defined when we talked about message definitions. This is not a mistake on our part but instead we kept it for later to define it another macro:</p>
<div class="fragment"><div class="line">DYNAMIX_DEFINE_MESSAGE_0_WITH_DEFAULT_IMPL(<span class="keywordtype">void</span>, render)</div><div class="line">{</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Rendering nothing&quot;</span> &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><p> <code>DYNAMIX_DEFINE_MESSAGE_N_WITH_DEFAULT_IMPL</code> where N is the number of arguments can be used to define messages in such a way that if they're called for an object that doesn't implement them, the default implementation will be called instead of an exception being thrown.</p>
<p>Note that you will have to copy the signature so it matches the one in the message declaration macro. Thus you will also gain access to the arguments if such exist.</p>
<p>The default implementation function, much like the implementation inside a mixin is a regular function. It can return values and have access to <code>dm_this</code>. The only thing to consider is that it will be discrarded if the object implements a message. For example while valid for a multicast, it won't be called if at least one mixin in the object implements it. Now we can safely call <code>render</code> for our trigger object:</p>
<div class="fragment"><div class="line">render(trigger); <span class="comment">// rendering nothing via a default message implementation</span></div></div><!-- fragment --><p> And that concludes our tutorial on messages.</p>
<h1><a class="anchor" id="message_bids"></a>
Message bids </h1>
<p>(For the complete, working source of this example see <a href="https://github.com/iboB/dynamix/blob/master/tutorial/bids.cpp">bids.cpp</a>)</p>
<p>After we covered the basic features of messages: unicasts, multicasts, priorities, overloads, and default implementations, let's now delve a bit deeper. Let's focus on message bids.</p>
<p>For this tutorial let's suppose we're writing an RPG game. Let's define a character mixin and some messages for it:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>character</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">int</span> get_health()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> _health;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> take_damage(<span class="keywordtype">int</span> dmg)</div><div class="line">    {</div><div class="line">        _health -= dmg;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">int</span> _health = 100;</div><div class="line">};</div><div class="line"></div><div class="line">DYNAMIX_CONST_MESSAGE_0(<span class="keywordtype">int</span>, get_health);</div><div class="line">DYNAMIX_MESSAGE_1(<span class="keywordtype">void</span>, take_damage, <span class="keywordtype">int</span>, dmg);</div><div class="line"></div><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(character, get_health_msg &amp; take_damage_msg);</div></div><!-- fragment --><p> In this game the different objects would need to be rendered on the screen in some way. For this, let's define functionality to do so.</p>
<p>Potentially multiple mixins in our objects would need some graphical visualization. For this our rendering design will have the multicast message <code>supply_rendering_data</code> which will fill an output list with the graphics for each mixin which implements it:</p>
<div class="fragment"><div class="line">DYNAMIX_CONST_MULTICAST_MESSAGE_1(<span class="keywordtype">void</span>, supply_rendering_data, vector&lt;string&gt;&amp;, out_data);</div></div><!-- fragment --><p> For simplicity in our example we'll just use <code>std::string</code> as "rendering" data.</p>
<p>Now we'll define a <code>render</code> function which takes an objects, calls the <code>supply_rendering_data</code> message and prints out the contents of string vector. In an real-world scenario of this sort, of course it would have some way of supplying the result to a rendering subsystem.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> render(<span class="keyword">const</span> <a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a>&amp; obj)</div><div class="line">{</div><div class="line">    vector&lt;string&gt; data;</div><div class="line">    supply_rendering_data(obj, data);</div><div class="line"></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Rendering:\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; elem : data)</div><div class="line">    {</div><div class="line">        cout &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> &lt;&lt; elem &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">    }</div><div class="line">    cout &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><p> The idealized rendering mixins for our example are <code>mesh</code> and <code>health_bar</code>. Meshes will represent how our object is visualized as a part of the game world, while health bars will visualize the health of a character (if the object is such) much like many RPG-s and strategy games do.</p>
<p>Getting the health for the object happens through the previously defined <code>get_health</code> message. This is a polymophic message call, because not only characters can have health in this game. Other objects might have it as well (say destructible crates or obstacles).</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>mesh</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> supply_rendering_data(vector&lt;string&gt;&amp; out_data)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        ostringstream sout;</div><div class="line">        sout &lt;&lt; <span class="stringliteral">&quot;Mesh: &quot;</span> &lt;&lt; _mesh;</div><div class="line">        out_data.push_back(sout.str());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">string</span> _mesh; <span class="comment">// just use std::string for simplicity</span></div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(mesh, supply_rendering_data_msg);</div><div class="line"></div><div class="line"><span class="keyword">class </span>health_bar</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> supply_rendering_data(vector&lt;string&gt;&amp; out_data)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        ostringstream sout;</div><div class="line">        sout &lt;&lt; <span class="stringliteral">&quot;Health: &quot;</span> &lt;&lt; get_health(<a class="code" href="mixin_8hpp.html#a8396cc680f14240e8e91a5bfdce4917d" title="a pointer to the owning object of the current mixin ">dm_this</a>);</div><div class="line">        out_data.push_back(sout.str());</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(health_bar, supply_rendering_data_msg);</div></div><!-- fragment --><p> Now, suppose that in our game we want some way of having invisible objects. Ar first this might seem like a straight forward case. We can just creata a mixin called <code>invisibility</code> which implements <code>supply_rendering_data</code> by adding a blur (or nothing) to the output list. Like so:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>invisibility</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> supply_rendering_data(vector&lt;string&gt;&amp; out_data)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        out_data.push_back(<span class="stringliteral">&quot;A blur&quot;</span>); <span class="comment">// think StarCraft :)</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> However <code>supply_rendering_data</code> is a multicast message. If we don't do anything else, adding this mixin to an object will result in the output list being filled with all existing parts <em>plus</em> a blur (or indeed nothing). Had <code>supply_rendering_data</code> been a unicast message, then we could've added a bigger priority to it so it overrides the original, but priority doesn't help us to override multicasts. It just determines the order.</p>
<p>There are of course many solutions to our problem using what you've learned so far (for example <code>invisibility::supply_rendering_data</code> can be last and used to clear the ouput list, or some kind of multicast result combinator can be used which breaks the mutlicast chain), but the cleanest and indeed most optimal solution is to use bids to override the mulcitast like so:</p>
<div class="fragment"><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(invisibility, bid(1, supply_rendering_data_msg));</div></div><!-- fragment --><p> Bids are similar to message priorities. For multicasts the priority determines the order of execution when the message is called. The bid determines which messages will be executed. They will be the ones with the highest bid (or top bidders).</p>
<p>So in the example from above, since <code>invisibility</code> bids 1 for <code>supply_rendering_data</code>, which is higher than the default zero, if we were to add it to an object, it would override the <code>supply_rendering_data</code> message (unless of course some mixins with an even higher bid are in there).</p>
<p>Of course, since this is a multicast, if we add other mixins which implement <code>supply_rendering_data</code> with the same bid, 1, their implentations will also be executed along with the one from <code>invisibility</code>. Let's see our resulting code in action:</p>
<div class="fragment"><div class="line"><span class="comment">// create a &quot;hero&quot; object and add our mixins to it</span></div><div class="line"><a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a> hero;</div><div class="line"></div><div class="line"><a class="code" href="classdynamix_1_1single__object__mutator.html">dynamix::mutate</a>(hero)</div><div class="line">    .add&lt;character&gt;()</div><div class="line">    .add&lt;mesh&gt;()</div><div class="line">    .add&lt;health_bar&gt;();</div><div class="line"></div><div class="line"><span class="comment">// set some &quot;mesh&quot;</span></div><div class="line">hero.<a class="code" href="classdynamix_1_1object.html#a3ac87d5fed5273a72e40cff82fe0a2c5">get</a>&lt;mesh&gt;()-&gt;_mesh = <span class="stringliteral">&quot;hero.mesh&quot;</span>;</div><div class="line"></div><div class="line"><span class="comment">// render a mesh and a health bar</span></div><div class="line">render(hero);</div><div class="line"></div><div class="line"><span class="comment">// add invisibility</span></div><div class="line"><span class="comment">// it will override supply_rendering_data from mesh and health_bar</span></div><div class="line"><a class="code" href="classdynamix_1_1single__object__mutator.html">dynamix::mutate</a>(hero)</div><div class="line">    .add&lt;invisibility&gt;();</div><div class="line"></div><div class="line"><span class="comment">// render a blur</span></div><div class="line">render(hero);</div></div><!-- fragment --><p> We saw how message bids can help us override multicast messages but what about unicasts. Is there a point to bids for them?</p>
<p>Yes there is but before we explain, let's continue with a motivating example.</p>
<p>Let's imagine that in our game we want a stoneskin effect. Stoneskin will cut all damage taken by an object in half and let's also (admittedly pointlessly) add the requirement that the stoneskin effect will add 10 more health points to the object.</p>
<p>It obvious that the <code>stoneskin</code> mixin would need to override <code>take_damage</code> and <code>get_health</code> to do so. So let's define our class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>stoneskin</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> take_damage(<span class="keywordtype">int</span> dmg);</div><div class="line">    <span class="keywordtype">int</span> get_health() <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p> We now have a problem. How do we implement these functions? We do need some way of transfering the newly calculated damage, or get the exisitng health. While we could write something like <code>dm_this-&gt;get&lt;character&gt;()-&gt;take_damage(dmg/2);</code>, we did mention that not only characters have health. Writing non-polymorphic code such as this won't work if we add stoneskin to a destructible object.</p>
<p>Unicast bids will help us in this case.</p>
<p>Superifically bids for unicasts work like finer grain priorities. If an object has mixins which implement the same unicast message with the same priority, the implementation with the highest bid will be executed (note the priority is the primary sort key in this case. So if one mixin implements a message with priority 10 and bid 1, and another with priority 1 and bid 1000, the first one's implenentation will be executed because it has the highest priority).</p>
<p>However when setting bids to unicasts, all bidders from the top priority will be available in an object which implements a message. This allows us to call a lower bidder from a higher one.</p>
<p>Think of this as calling the superclass's virtual method from the one that overrides it in a sublass.</p>
<p>If you override a unicast message by adding a mixin to an object which already implements it, when only priorities are involved, the overriden implementation is inaccessible and lost until we remove the mixin. However bids allow us to call the DYNAMIX_CALL_NEXT_BIDDER macro from a message implementation to call a lower bidder with the same priority which we have overriden.</p>
<div class="fragment"><div class="line"><span class="comment">// implement the messages with higher bids</span></div><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(stoneskin, bid(1, get_health_msg) &amp; bid(1, take_damage_msg));</div><div class="line"></div><div class="line"><span class="comment">// call next bidders modifying values by the stoneskin effect</span></div><div class="line"><span class="keywordtype">void</span> stoneskin::take_damage(<span class="keywordtype">int</span> dmg)</div><div class="line">{</div><div class="line">    <a class="code" href="next__bidder_8hpp.html#acab23c3cf8881bb4a98add7b2df5c3ec" title="Macro that calls the next bidder from a message with a higher bid. ">DYNAMIX_CALL_NEXT_BIDDER</a>(take_damage_msg, dmg / 2);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> stoneskin::get_health()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="next__bidder_8hpp.html#acab23c3cf8881bb4a98add7b2df5c3ec" title="Macro that calls the next bidder from a message with a higher bid. ">DYNAMIX_CALL_NEXT_BIDDER</a>(get_health_msg) + 10;</div><div class="line">}</div></div><!-- fragment --><p> As you can see to call the next bidder, you need to supply the message tag as an argument. Otherwise the macro behaves exacly like the underlying function: it has the same arguments and the same return value.</p>
<p>The need to supply the message tag helps us to also call next bidders from methods which don't necessarily implement the message in question. Now let's use our unicast bids and calling of next bidders:</p>
<div class="fragment"><div class="line"><span class="comment">// hit the hero with 20 damage</span></div><div class="line">take_damage(hero, 20);</div><div class="line"></div><div class="line"><span class="comment">// rendering hero with health 80 (from initial 100)</span></div><div class="line">render(hero);</div><div class="line"></div><div class="line"><a class="code" href="classdynamix_1_1single__object__mutator.html">dynamix::mutate</a>(hero)</div><div class="line">    .add&lt;stoneskin&gt;();</div><div class="line"></div><div class="line"><span class="comment">// with stoneskin the health is +10</span></div><div class="line"><span class="comment">// so now we render a hero with health 90</span></div><div class="line">render(hero);</div><div class="line"></div><div class="line"><span class="comment">// hit the hero with 50 damage</span></div><div class="line"><span class="comment">// stoneskin will transfer 25</span></div><div class="line">take_damage(hero, 50);</div><div class="line"></div><div class="line"><span class="comment">// render hero with 80 + 10 - 25 = 65 health</span></div><div class="line">render(hero);</div></div><!-- fragment --><h1><a class="anchor" id="obj_mutation"></a>
Object mutation </h1>
<p>(For the complete, working source of this example see <a href="https://github.com/iboB/dynamix/blob/master/tutorial/mutation.cpp">mutation.cpp</a>)</p>
<p>For this tutorial let's begin by introducing some mixins that may be found in a game: A root mixin, that should be present in all objects, and two that provide a way to render the object on the screen:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>game_object</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> _id;</div><div class="line">    <span class="keywordtype">string</span> name;</div><div class="line">    <span class="comment">// ... other common fields</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>opengl_rendering {};</div><div class="line"></div><div class="line"><span class="keyword">class </span>directx_rendering {};</div></div><!-- fragment --><p> We won't concern ourselves with their concrete functionality, so we'll just leave them with no messages.</p>
<div class="fragment"><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(game_object, dynamix::none);</div><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(opengl_rendering, dynamix::none);</div><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(directx_rendering, dynamix::none);</div></div><!-- fragment --><p> You're probably familiar from the previous examples with the most basic way to mutate an object, so let's use it to give this one a type.</p>
<div class="fragment"><div class="line"><a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a> obj1;</div><div class="line"><a class="code" href="classdynamix_1_1single__object__mutator.html">dynamix::mutate</a>(obj1)</div><div class="line">    .add&lt;game_object&gt;()</div><div class="line">    .add&lt;opengl_rendering&gt;();</div></div><!-- fragment --><p> ...and then change it. Let's assume we're switching our rendering platform.</p>
<div class="fragment"><div class="line"><a class="code" href="classdynamix_1_1single__object__mutator.html">dynamix::mutate</a>(obj1)</div><div class="line">    .remove&lt;opengl_rendering&gt;()</div><div class="line">    .add&lt;directx_rendering&gt;();</div></div><!-- fragment --><p> Using the <code>mutate</code> class is probably the most common way in which you'll mutate objects in DynaMix. Yes, <code>mutate</code> is not a function but a class. It has methods <code>remove</code> and <code>add</code>, and in its destructor it applies the actual mutation.</p>
<p>A mutation is a relatively slow process so if the internal object type was being changed on each call of <code>remove</code> or <code>add</code>, first the program would be needlessly slowed down, and second the library would need to deal with various incomplete types in its internal type registry.</p>
<p>So, if you want to add and remove mixins across several blocks or functions, you may safely instantiate the <code>mutate</code> class or use its typedef <code>single_object_mutator</code> that probably has a more appropriate name for cases like this.</p>
<div class="fragment"><div class="line"><a class="code" href="classdynamix_1_1single__object__mutator.html">dynamix::single_object_mutator</a> mutation(obj1);</div><div class="line"></div><div class="line">mutation.remove&lt;directx_rendering&gt;();</div><div class="line"><span class="comment">// ...</span></div><div class="line">mutation.add&lt;opengl_rendering&gt;();</div></div><!-- fragment --><p> Here <code>obj1</code> hasn't been mutated yet. A type that has <code>game_object</code> and <code>opengl_rendering</code> hasn't been instantiated internally. In order for this to happen the <code>mutation</code> instance needs to be destroyed, or, to explicitly perform the mutation, you may call <code>apply</code> like so:</p>
<div class="fragment"><div class="line">mutation.apply();</div></div><!-- fragment --><p> Now <code>obj1</code> has been mutated, and <code>mutation</code> has been "cleared" &ndash; returned to the empty state it had right after its instantiation. This means we can reuse it to perform other mutation on <code>obj1</code>. Say:</p>
<div class="fragment"><div class="line">mutation.remove&lt;game_object&gt;();</div></div><!-- fragment --><p> Oops! We're removing the mixin that needs to be present in all objects. Not to worry. You may "clear" a mutation without applying it, by calling <code>cancel</code>.</p>
<div class="fragment"><div class="line">mutation.cancel();</div></div><!-- fragment --><p> Now the mutation is not performed, and its state is empty.</p>
<p>You may safely apply empty mutations to an object:</p>
<div class="fragment"><div class="line">mutation.apply(); <span class="comment">// no effect</span></div></div><!-- fragment --><p> Another way to mutate objects is by using a type template.</p>
<p>A type template gives a type to an object and, unlike <code>mutate/single_object_mutator</code> it's not bound to a specific object instance. Again unlike <code>mutate</code> it disregards all mixins within an object and applies its internal type, hence it has no <code>remove</code> method. It implicitly "removes" all mixins that are not among its own.</p>
<p>You can create a type template like so:</p>
<div class="fragment"><div class="line"><a class="code" href="classdynamix_1_1object__type__template.html">dynamix::object_type_template</a> directx_rendering_template;</div><div class="line">directx_rendering_template</div><div class="line">    .add&lt;game_object&gt;()</div><div class="line">    .add&lt;directx_rendering&gt;()</div><div class="line">    .create();</div></div><!-- fragment --><p> Again, similar to the case with <code>single_object_mutator</code>, you can spread these calls among many blocks or functions.</p>
<p>Don't forget to call <code>create</code>. It is the method that creates the internal object type. If you try to apply a type template that hasn't been created to an object, a runtime error will be triggered.</p>
<p>To apply a type template to an object, you may pass it as a parameter to its constructor.</p>
<div class="fragment"><div class="line"><a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a> obj2(directx_rendering_template);</div></div><!-- fragment --><p> Now <code>obj2</code> has the mixins <code>game_object</code> and <code>directx_rendering</code>.</p>
<p>Let's create a new type template.</p>
<div class="fragment"><div class="line"><a class="code" href="classdynamix_1_1object__type__template.html">dynamix::object_type_template</a> opengl_rendering_template;</div><div class="line">opengl_rendering_template</div><div class="line">    .add&lt;game_object&gt;()</div><div class="line">    .add&lt;opengl_rendering&gt;()</div><div class="line">    .create();</div></div><!-- fragment --><p> ...to illustrate the other way of applying it to an object:</p>
<div class="fragment"><div class="line">opengl_rendering_template.apply_to(obj2);</div></div><!-- fragment --><p> Applying this type template it the same object, was equivalent to <code>mutate</code>-ing it, removing <code>directx_rendering</code> and adding <code>opengl_rendering</code>.</p>
<p>Now we have two objects &ndash; <code>obj1</code> and <code>obj2</code> &ndash; that have the same mixins.</p>
<p>Sometimes the case would be such that you have a big group of objects that have the exact same type internally, and want them all to be mutated to have a different type. Naturally you may <code>mutate</code> each of them one by one, and this would be the appropriate (and only) way to mutate a group of objects that have a /different/ type.</p>
<p>If the type is the same, however, you have a slightly faster alternative. The same type mutator:</p>
<div class="fragment"><div class="line"><a class="code" href="classdynamix_1_1same__type__mutator.html">dynamix::same_type_mutator</a> directx;</div><div class="line">directx</div><div class="line">    .remove&lt;opengl_rendering&gt;()</div><div class="line">    .add&lt;directx_rendering&gt;();</div></div><!-- fragment --><p> Unlike type templates, same type mutators don't need you to create them explicitly with some method. The creation of the internal type and all preparations are done when the mutation is applied to the first object.</p>
<div class="fragment"><div class="line">directx.apply_to(obj1);</div><div class="line">directx.apply_to(obj2);</div></div><!-- fragment --><p> Remember that the only time you can afford to use a same type mutator, is when /all/ objects that need to be mutated with it are composed of the same set of mixins.</p>
<h1><a class="anchor" id="mut_rules"></a>
Mutation rules </h1>
<p>(For the complete, working source of this example see <a href="https://github.com/iboB/dynamix/blob/master/tutorial/mutation_rules.cpp">mutation_rules.cpp</a>)</p>
<p>Let's define some mixins that may be present in a CAD system specialized for furniture design. Like in the previous example, we won't concern ourselves with any particular messages.</p>
<p>So, again we have a mixin that we want to be present in every object.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>furniture</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> _id;</div><div class="line">    <span class="keywordtype">string</span> name;</div><div class="line">    <span class="comment">// ... other common fields</span></div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(furniture, dynamix::none);</div></div><!-- fragment --><p> We also have mixins that describe the frame of the piece of furniture.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>wood_frame {};</div><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(wood_frame, dynamix::none);</div><div class="line"></div><div class="line"><span class="keyword">class </span>metal_frame {};</div><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(metal_frame, dynamix::none);</div></div><!-- fragment --><p> Let's also define some mixins that will be responsible for the object serialization.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ofml_serialization {};</div><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(ofml_serialization, dynamix::none);</div><div class="line"></div><div class="line"><span class="keyword">class </span>xml_serialization {};</div><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(xml_serialization, dynamix::none);</div></div><!-- fragment --><p> And finally let's define two mixins that would help us describe our piece of furniture if it can contain objects inside &ndash; like a cabinet or a wardrobe.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>has_doors {};</div><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(has_doors, dynamix::none);</div><div class="line"></div><div class="line"><span class="keyword">class </span>container {};</div><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(container, dynamix::none);</div></div><!-- fragment --><p> Now, let's move on to the entry point of our program.</p>
<p>We said that each and every object in our system should be expected to have the mixin <code>furniture</code>. That could be accomplished if we manually add it to all mutations we make but there is a simpler way to do it. By adding the <code>mandatory_mixin</code> mutation rule.</p>
<p>All mutation rules should be added by calling <code>add_mutation_rule</code>. Since <code>mandatory_mixin</code> is a mutation rule that the library provides, we can accomplish this with a single line of code:</p>
<div class="fragment"><div class="line"><a class="code" href="mutation__rule_8hpp.html#a756e2ea0f0d52be5a3315d8c3f90c54f">dynamix::add_mutation_rule</a>(<span class="keyword">new</span> <a class="code" href="classdynamix_1_1mandatory__mixin.html">dynamix::mandatory_mixin&lt;furniture&gt;</a>);</div></div><!-- fragment --><p> Now each mutation after this line will add <code>furniture</code> to the objects (even if it's not been explicitly added) and also if a mutation tries to remove the <code>furniture</code> mixin from the object, it won't be allowed. There won't be an error or a warning. The library will silently ignore the request to remove <code>furniture</code>, or any other mixin that's been added as mandatory. Note, that if a mutation tries to remove <code>furniture</code>, and also adds and removes other mixins, only the part removing the mandatory mixin will be ignored. The others will be performed.</p>
<p>Another common case for using <code>mandatory_mixin</code> is if you want to have some debugging mixin, that you want present in you objects, when you're debugging your application. This is very easily accomplished if you just set the rule for it in a conditional compilation block.</p>
<p>You probably noticed the mixin <code>ofml_serialization</code>. OFML is a format specifically designed for describing furniture that's still used in some European countries, but hasn't gotten worldwide acceptance. Let's assume we want to drop the support for OFML, but without removing the actual code, since third party plugins to our CAD system may still depend on it. All we want is to prevent anybody from adding the mixin to an object. Basically the exact opposite of <code>mandatory_mixin</code>. This is the mutation rule <code>deprecated_mixin</code></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <span class="keywordtype">id</span> = <a class="code" href="mutation__rule_8hpp.html#a756e2ea0f0d52be5a3315d8c3f90c54f">dynamix::add_mutation_rule</a>(<span class="keyword">new</span> <a class="code" href="classdynamix_1_1deprecated__mixin.html">dynamix::deprecated_mixin&lt;ofml_serialization&gt;</a>);</div></div><!-- fragment --><p> After that line of code, any mutation that tries to add <code>ofml_serialization</code> won't be able to, and all mutations will try to remove it if it's present in an object. Again, as was the case before, if a mutation does many things, only the part from it, trying to add <code>ofml_serialization</code> will be silently ignored. Also, we will store the id of the newly added rule for the next example.</p>
<p>Mutation rules are registered globally and they are ran on every mutation, inadvertedly slowing it down. Sometimes you will encounter the need to add a mutation rule which is needed or only makes sense for a limited amount of time. For example deprecating <code>ofml_serialization</code> from the source line above might only be needed when loading objects and then our code might never add it, rendering this rule useless for the majority of the program's run. In such cases we can remove a rule with <code>remove_mutation_rule</code> like so:</p>
<div class="fragment"><div class="line"><a class="code" href="mutation__rule_8hpp.html#a2ef7297f259a22a572157d471aab7ccc">dynamix::remove_mutation_rule</a>(<span class="keywordtype">id</span>);</div></div><!-- fragment --><p> The last built-in rule in the library is <code>mutually_exclusive_mixins</code>.</p>
<p>Since a piece of furniture has either wood frame or a metal frame and never both, it would be a good idea to prevent the programmers from accidentally adding both mixins representing the frame in a single object. This mutation rule helps us do exactly that.</p>
<div class="fragment"><div class="line"><a class="code" href="classdynamix_1_1mutually__exclusive__mixins.html">dynamix::mutually_exclusive_mixins</a>* rule = <span class="keyword">new</span> <a class="code" href="classdynamix_1_1mutually__exclusive__mixins.html">dynamix::mutually_exclusive_mixins</a>;</div><div class="line">rule-&gt;<a class="code" href="classdynamix_1_1mixin__collection.html#adc40b0c54adfbabc7321427a22f0a4b5" title="Adds a mixin type is to the collection. ">add</a>&lt;wood_frame&gt;();</div><div class="line">rule-&gt;<a class="code" href="classdynamix_1_1mixin__collection.html#adc40b0c54adfbabc7321427a22f0a4b5" title="Adds a mixin type is to the collection. ">add</a>&lt;metal_frame&gt;();</div><div class="line"><a class="code" href="mutation__rule_8hpp.html#a756e2ea0f0d52be5a3315d8c3f90c54f">dynamix::add_mutation_rule</a>(rule);</div></div><!-- fragment --><p> You may add as many mutually exclusive mixins as you wish. If you had, say, <code>plastic_frame</code>, you could also add it to that list.</p>
<p>Any object mutated after that rule is set will implicitly remove any of the mutually exclusive mixins if another is added.</p>
<p>In many of our examples a sample game code was given, with mixins <code>opengl_rendering</code> and <code>directx_rendering</code>. The <code>mutually_exclusive_mixins</code> is perfect for this case and any other when we're always doing <code>add&lt;x&gt;().remove&lt;y&gt;()</code> and <code>add&lt;y&gt;().remove&lt;x&gt;()</code>.</p>
<p>So to see this in practice:</p>
<div class="fragment"><div class="line"><a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a> o;</div></div><!-- fragment --><p> This object is empty. Mutation rules don't apply if there's no mutation. If, however, the object had been created with a type template passed in its constructor, then the rules would have been applied.</p>
<div class="fragment"><div class="line"><a class="code" href="classdynamix_1_1single__object__mutator.html">dynamix::mutate</a>(o)</div><div class="line">    .add&lt;ofml_serialization&gt;()</div><div class="line">    .add&lt;xml_serialization&gt;()</div><div class="line">    .add&lt;wood_frame&gt;();</div></div><!-- fragment --><p> Two rules are affected by this mutation. First it will implicitly add <code>furniture</code> to the object, and second it will ignore the attempt to add <code>ofml_serialization</code>. As a result the object will have <code>furniture</code>, <code>xml_serialization</code> and <code>wood_frame</code>.</p>
<div class="fragment"><div class="line"><a class="code" href="classdynamix_1_1single__object__mutator.html">dynamix::mutate</a>(o)</div><div class="line">    .add&lt;metal_frame&gt;();</div></div><!-- fragment --><p> The mutually exclusive mixins will ensure that after this line the object won't have the <code>wood_frame</code> mixin.</p>
<p>Having listed some built-in mutation rules, let's now define a custom one.</p>
<p>Defining a custom rule is very easy. All you need to do is create a class derived from <code><a class="el" href="classdynamix_1_1mutation__rule.html" title="Base class for all mutation rules. ">dynamix::mutation_rule</a></code> and override its pure virtual method <code>apply_to</code>. The method has a single input-output parameter &ndash; the mutation that has been requested.</p>
<p>If you remember, we defined two mixins we haven't yet used &ndash; <code>has_doors</code> and <code>container</code>. We can safely say that a piece of furniture that has doors is always also a container (The opposite is not true. Think racks and bookcases). So it would be a good idea to add a mutation rule which adds the <code>container</code> mixin if <code>has_doors</code> is being added, and removes <code>has_doors</code> if <code>container</code> is being removed and the object has doors.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>container_rule : <span class="keyword">public</span> <a class="code" href="classdynamix_1_1mutation__rule.html" title="Base class for all mutation rules. ">dynamix::mutation_rule</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classdynamix_1_1mutation__rule.html#a22b9b5bf66f70dc93290fd618e44afab" title="Called when applying the mutation rule. ">apply_to</a>(<a class="code" href="classdynamix_1_1object__type__mutation.html">dynamix::object_type_mutation</a>&amp; mutation)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span>(mutation.<a class="code" href="classdynamix_1_1object__type__mutation.html#aabd79be48775f2dd5f7c159b13800f11" title="Checks if the mutation is adding a mixin. ">is_adding</a>&lt;has_doors&gt;())</div><div class="line">        {</div><div class="line">            mutation.<a class="code" href="classdynamix_1_1object__type__mutation.html#a79d8cbfbfde17336587561b0d0e0810e" title="Adds a mixin to the ones being added by the mutation. ">start_adding</a>&lt;container&gt;();</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span>(mutation.<a class="code" href="classdynamix_1_1object__type__mutation.html#abeb8f324990efe187153ea3a61ff6e21" title="Checks if the mutation is removing a mixin. ">is_removing</a>&lt;container&gt;() &amp;&amp; mutation.<a class="code" href="classdynamix_1_1object__type__mutation.html#ab8b0033c5e14006504484145e74fa5e6" title="Checks if the mutation&#39;s source has a mixin. ">source_has</a>&lt;has_doors&gt;())</div><div class="line">        {</div><div class="line">            mutation.<a class="code" href="classdynamix_1_1object__type__mutation.html#ab293c80c5627f5a81a30064c30ddd3a1" title="Adds a mixin to the ones being removed by the mutation. ">start_removing</a>&lt;has_doors&gt;();</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> That's it. Now all we have to do is add our mutation rule and it will be active.</p>
<div class="fragment"><div class="line"><a class="code" href="mutation__rule_8hpp.html#a756e2ea0f0d52be5a3315d8c3f90c54f">dynamix::add_mutation_rule</a>(<span class="keyword">new</span> container_rule);</div><div class="line"></div><div class="line"><a class="code" href="classdynamix_1_1single__object__mutator.html">dynamix::mutate</a>(o)</div><div class="line">    .add&lt;has_doors&gt;();</div></div><!-- fragment --><p> After this mutation our custom mutation rule has also added <code>container</code> to the object.</p>
<div class="fragment"><div class="line"><a class="code" href="classdynamix_1_1single__object__mutator.html">dynamix::mutate</a>(o)</div><div class="line">    .remove&lt;container&gt;();</div></div><!-- fragment --><p> And after this line, thanks to our custom mutation rule, the object <code>o</code> will also have its <code>has_doors</code> mixin removed.</p>
<p>To see all ways in which you can change a mutation from the mutation rule, check out the documentation entry on <code>object_type_mutation</code>.</p>
<p>Lastly, there are three more important pieces of information about mutation rules that you need to know.</p>
<p>In these examples we always added mutation rule pointers, allocated with <code>new</code>. In such case the library will take ownership of the pointer and will be responsible for destroying and deallocating the rules you've added. However you can also add mutation rules with <code>std::shared_ptr</code> and keep ownership even after they are removed (and potentially readd them).</p>
<p>Second, you may have noticed that mutation rules can logically depend on each other. You may ask yourselves what does the library do about that? Does it do a topological sort of the rules? Say we add a mandatory /and/ a deprecated rule about the same mixin. How does it handle dependency loops?</p>
<p>The answer is simple. It doesn't. The rules are applied once per mutation in the order in which they were added. It is the responsibility of the user to add them in some sensible order. Had the library provided some form of rule sort, it would have needlessly overcomplicated the custom rule definition, especially for cases in which you actually want to... well, overrule a rule.</p>
<p>So, that's all there is to know about mutation rules.</p>
<h1><a class="anchor" id="mult_combinators"></a>
Multicast result combinators </h1>
<p>(For the complete, working source of this example see <a href="https://github.com/iboB/dynamix/blob/master/tutorial/combinators.cpp">combinators.cpp</a>)</p>
<p>For this tutorial let's imagine we have a simple CAD program, which deals designing 3-dimensional objects. In such programs various aspects of an object need to be visible and editable at different times. Let's assume our objects are defined by their wireframe, their vertices, and their surface.</p>
<p>We'll define mixins for those and focus on the parts they have in common: namely whether an part of the object is visible, and how much elements is this part composed of.</p>
<div class="fragment"><div class="line"><a class="code" href="mixin_8hpp.html#acebfdad3adf70d4da7e221d7fdf8fb6d" title="Declares a class as a mixin. ">DYNAMIX_DECLARE_MIXIN</a>(wireframe);</div><div class="line"></div><div class="line"><span class="keyword">class </span>wireframe</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> set_visible(<span class="keywordtype">bool</span> value);</div><div class="line">    <span class="keywordtype">void</span> set_elements_count(<span class="keywordtype">int</span> count);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> visible() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">int</span> elements_count() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">bool</span> _visible;</div><div class="line">    <span class="keywordtype">int</span> _elements_count;</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="mixin_8hpp.html#acebfdad3adf70d4da7e221d7fdf8fb6d" title="Declares a class as a mixin. ">DYNAMIX_DECLARE_MIXIN</a>(vertices);</div><div class="line"></div><div class="line"><span class="keyword">class </span>vertices</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> set_visible(<span class="keywordtype">bool</span> value);</div><div class="line">    <span class="keywordtype">void</span> set_elements_count(<span class="keywordtype">int</span> count);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> visible() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">int</span> elements_count() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">bool</span> _visible;</div><div class="line">    <span class="keywordtype">int</span> _elements_count;</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="mixin_8hpp.html#acebfdad3adf70d4da7e221d7fdf8fb6d" title="Declares a class as a mixin. ">DYNAMIX_DECLARE_MIXIN</a>(surface);</div><div class="line"></div><div class="line"><span class="keyword">class </span>surface</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> set_visible(<span class="keywordtype">bool</span> value);</div><div class="line">    <span class="keywordtype">void</span> set_elements_count(<span class="keywordtype">int</span> count);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> visible() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">int</span> elements_count() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">bool</span> _visible;</div><div class="line">    <span class="keywordtype">int</span> _elements_count;</div><div class="line">};</div></div><!-- fragment --><p> Now let's define messages for the methods we'll want to access polymorphically and define our mixins to use those messages.</p>
<div class="fragment"><div class="line">DYNAMIX_CONST_MULTICAST_MESSAGE_0(<span class="keywordtype">bool</span>, visible);</div><div class="line">DYNAMIX_CONST_MULTICAST_MESSAGE_0(<span class="keywordtype">int</span>, elements_count);</div><div class="line"></div><div class="line"><a class="code" href="message__macros_8hpp.html#a4ea78051262bb047d5127da21a2e7af0">DYNAMIX_DEFINE_MESSAGE</a>(visible);</div><div class="line"><a class="code" href="message__macros_8hpp.html#a4ea78051262bb047d5127da21a2e7af0">DYNAMIX_DEFINE_MESSAGE</a>(elements_count);</div><div class="line"></div><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(vertices, visible_msg &amp; elements_count_msg);</div><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(wireframe, visible_msg &amp; elements_count_msg);</div><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(surface, visible_msg &amp; elements_count_msg);</div></div><!-- fragment --><p> As you can see those are multicast messages. Each of the mixins in the object will implement and respond to them.</p>
<p>Now let's create some objects.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> NUM_OBJECTS = 20;</div><div class="line"><a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a> objects[NUM_OBJECTS];</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a>&amp; o = objects[0];</div></div><!-- fragment --><p> ...and mutate them with some mixins, and give them some values.</p>
<p>For example let's say all of our objects are cubes, that have 24 vertices (4 per side), 6 squares for the wireframe, and a single (folded) surface.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;NUM_OBJECTS; ++i)</div><div class="line">{</div><div class="line">    <a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a>&amp; o = objects[i];</div><div class="line"></div><div class="line">    <a class="code" href="classdynamix_1_1single__object__mutator.html">dynamix::mutate</a>(o)</div><div class="line">        .add&lt;vertices&gt;()</div><div class="line">        .add&lt;wireframe&gt;()</div><div class="line">        .add&lt;surface&gt;();</div><div class="line"></div><div class="line">    o.<a class="code" href="classdynamix_1_1object.html#a3ac87d5fed5273a72e40cff82fe0a2c5">get</a>&lt;vertices&gt;()-&gt;set_elements_count(24);</div><div class="line">    o.<a class="code" href="classdynamix_1_1object.html#a3ac87d5fed5273a72e40cff82fe0a2c5">get</a>&lt;vertices&gt;()-&gt;set_visible(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    o.<a class="code" href="classdynamix_1_1object.html#a3ac87d5fed5273a72e40cff82fe0a2c5">get</a>&lt;wireframe&gt;()-&gt;set_elements_count(6);</div><div class="line">    o.<a class="code" href="classdynamix_1_1object.html#a3ac87d5fed5273a72e40cff82fe0a2c5">get</a>&lt;wireframe&gt;()-&gt;set_visible(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    o.<a class="code" href="classdynamix_1_1object.html#a3ac87d5fed5273a72e40cff82fe0a2c5">get</a>&lt;surface&gt;()-&gt;set_elements_count(1);</div><div class="line">    o.<a class="code" href="classdynamix_1_1object.html#a3ac87d5fed5273a72e40cff82fe0a2c5">get</a>&lt;surface&gt;()-&gt;set_visible(<span class="keyword">true</span>);</div><div class="line">}</div></div><!-- fragment --><p> As you may have noticed, all of our messages are functions that have a return value. You may have tried making multicast messages with non-void functions and noticed that the generated message function is void and doesn't return anything.</p>
<p>The things that will help us make use of the values returned from the messages are the multicast result combinators.</p>
<p>So, let's say we want to see if an object is visible. We say that it is visible if at least one of its mixins is. To get this value we may use the combinator <code>boolean_or</code> provided by the library (all built-in combinators are in namespace <code>dynamix::combinators</code>)</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> is_first_visible = visible&lt;dynamix::combinators::boolean_or&gt;(o);</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;The first object is &quot;</span> &lt;&lt; (is_first_visible ? <span class="stringliteral">&quot;visible&quot;</span> : <span class="stringliteral">&quot;invisible&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; endl;</div></div><!-- fragment --><p> That's it. Giving a combinator as an explicit template argument to a multicast message call, will call a function that <em>has</em> a return value defined by the combinator. In this case <code>boolean_or</code> causes the message to return a <code>bool</code> which is true if at least one of the messages returns non-zero.</p>
<p>Had we defined that an object is visible if <em>all</em> of its mixins were visible, then we could have used the built-in combinator <code>boolean_and</code>.</p>
<p>Now let's look at another built-in combinator &ndash; <code>sum</code>. You may have guessed that it's a sum of all values returned by the messages. In our case we may want to check how many elements are there in an object:</p>
<div class="fragment"><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;There are &quot;</span> &lt;&lt; elements_count&lt;dynamix::combinators::sum&gt;(o) &lt;&lt; <span class="stringliteral">&quot; elements in the first object.&quot;</span> &lt;&lt; endl;</div></div><!-- fragment --><p> All built-in combinators have an alternative usage. You saw the first, where putting the combinator as a template argument, causes the message to return a value.</p>
<p>The second usage keeps the message function <code>void</code>, but lets you add the combinator as an output parameter. This way, for example you may sum all elements throughout all objects with a single reusable combinator:</p>
<div class="fragment"><div class="line"><a class="code" href="classdynamix_1_1combinators_1_1sum.html">dynamix::combinators::sum&lt;int&gt;</a> sum;</div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;NUM_OBJECTS; ++i)</div><div class="line">{</div><div class="line">    elements_count(objects[i], sum);</div><div class="line">}</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;There are &quot;</span> &lt;&lt; sum.<a class="code" href="classdynamix_1_1combinators_1_1sum.html#a60cb860ca0168039fb240e67af81b1cc">result</a>() &lt;&lt; <span class="stringliteral">&quot; elements among all objects.&quot;</span> &lt;&lt; endl;</div></div><!-- fragment --><p> That's basically all there is to know about using combinators. Now, let's move on to creating our own custom ones. The built-in combinators are powerful, but sometimes you need to accomplish a task where you need some specific combinator behavior and need to add a custom one.</p>
<p>To create a custom combinator that's used as an output parameter is very easy. All you need to do is create a class, that has a public method called <code>add_result</code>. This public method should take one argument of the same type as (or one that can be implicitly cast to) the return type of the multicast message that you're "combining" with it. The method will be repeatedly called with each successful message with its return value as an argument. It should return <code>bool</code> &ndash; <code>true</code> when the execution should continue and <code>false</code> when it should stop.</p>
<p>We mentioned <code>boolean_or</code> and <code>boolean_and</code>. The function <code>add_result</code> in <code>boolean_or</code> returns false on the first non-zero value. That means it has determined the the final value is true (because at least one true has been met) and there is no need to execute the rest. Likewise <code>boolean_and</code>'s <code>add_result</code> returns false on the first zero value it gets. Exactly as C++'s operators <code>||</code> and <code>&amp;&amp;</code> behave.</p>
<p>So let's define our output parameter combinator that counts all mixins that have more than 1 element. Also, we <em>could</em> call it for a single object, but let's make use of the fact that it's an output parameter and count all mixins with more than 1 element among all objects:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>more_than_1</div><div class="line">{</div><div class="line">    more_than_1() : count(0) {}</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> add_result(<span class="keywordtype">int</span> elements)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span>(elements &gt; 1)</div><div class="line">            ++count;</div><div class="line"></div><div class="line">        <span class="comment">// Never break. We need this for all mixins in an object</span></div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> count;</div><div class="line">};</div><div class="line"></div><div class="line">more_than_1 counter;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;NUM_OBJECTS; ++i)</div><div class="line">{</div><div class="line">    elements_count(objects[i], counter);</div><div class="line">}</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;There are &quot;</span> &lt;&lt; counter.count &lt;&lt; <span class="stringliteral">&quot; mixins with more than 1 element among all objects.&quot;</span> &lt;&lt; endl;</div></div><!-- fragment --><p> Another case we need to cover is when you want your custom combinator to be added as a template argument to the message's function giving it a return value of its own.</p>
<p>To do this is only slightly more complicated the the previous return parameter case.</p>
<p>You need to create a template class whose template parameter will be provided by the message call and will be the message return type.</p>
<p>Next, as before you'll need an <code>add_result</code> method to be repeatedly called, again having a single argument of type equal to the message return type (you may just reuse the template argument of the combinator class), and again returning <code>bool</code> to indicate whether the message execution should continue or stop.</p>
<p>Next, you'll need a typedef <code>result_type</code>, which will indicate the return type of the message function.</p>
<p>Lastly, you'll have to create a method, called result, with no arguments, that has a return type <code>result_type</code>. It will be called when the execution is completed and it will provide the return value of the message function.</p>
<p>So, let's create an identical combinator as before &ndash; one that counts the mixins in an object that have more than one element, but this time to be used as a template argument of the message function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MsgReturnType&gt;</div><div class="line"><span class="keyword">struct </span>more_than_1_t</div><div class="line">{</div><div class="line">    more_than_1_t() : count(0) {}</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> add_result(MsgReturnType elements)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span>(elements &gt; 1)</div><div class="line">            ++count;</div><div class="line"></div><div class="line">        <span class="comment">// Never break. We need this for all mixins in an object</span></div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// return type of message function</span></div><div class="line">    <span class="keyword">typedef</span> <span class="keywordtype">int</span> result_type;</div><div class="line"></div><div class="line">    result_type result()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> count;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> count;</div><div class="line">};</div></div><!-- fragment --><p> Now we can use our new custom combinator as we used <code>boolean_or</code> above.</p>
<div class="fragment"><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;There are &quot;</span> &lt;&lt; elements_count&lt;more_than_1_t&gt;(o)</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot; mixins with more than 1 element in the first object.&quot;</span> &lt;&lt; endl;</div></div><!-- fragment --><p> The last example in this tutorial deals with finding the number of times your <code>add_result</code> function will be called.</p>
<p>Suppose you want to implement a combinator which collects all execution results of the messages in the multicast in a vector. Now, this is easy, given what we've learned so far. Just create the combinator and call <code>vec.push_back</code> for each result in <code>add_result</code>. Then simply use it like this:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> results = elements_count&lt;collection_t&gt;(o);</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;The number of elemens per mixin in the first object is:\n&quot;</span>;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> i : results)</div><div class="line">{</div><div class="line">    cout &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> &lt;&lt; i &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><p> This, however, will potentially cause useless allocations. A much better implementation would call <code>vec.reserve</code> before calling <code>push_back</code> many times.</p>
<p>The library helps you do this by allowing combinator classes to have an optional method <code>set_num_results(size_t)</code>. If a combinator has such, it will be called by the runtime before executing the methods associated with the multicast message. Here is a sample custom combinator which allows the user to collect all return values and also calls reserve with an appropriate size:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MsgReturnType&gt;</div><div class="line"><span class="keyword">struct </span>collection_t</div><div class="line">{</div><div class="line">    <span class="keywordtype">void</span> set_num_results(<span class="keywordtype">size_t</span> num)</div><div class="line">    {</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;collection_t reserving space for &quot;</span> &lt;&lt; num &lt;&lt; <span class="stringliteral">&quot; results.&quot;</span> &lt;&lt; endl;</div><div class="line">        results.reserve(num);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> add_result(MsgReturnType result)</div><div class="line">    {</div><div class="line">        results.push_back(result);</div><div class="line"></div><div class="line">        <span class="comment">// Never break. We need this for all mixins in an object</span></div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// return type of message function</span></div><div class="line">    <span class="keyword">typedef</span> std::vector&lt;MsgReturnType&gt; result_type;</div><div class="line"></div><div class="line">    result_type result()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> results;</div><div class="line">    }</div><div class="line"></div><div class="line">    std::vector&lt;MsgReturnType&gt; results;</div><div class="line">};</div></div><!-- fragment --><p> And that's all there is about multicast result combinators.</p>
<h1><a class="anchor" id="tips_tricks"></a>
Tips and tricks </h1>
<ul>
<li>When adding the same set of messages to multiple mixins, create a <code>define</code> for them all. Like: <code>#define transform_messages set_position_msg &amp; set_orientation_msg</code>. Then use it like this <code><a class="el" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN(x, some_messages &amp; transform_messages)</a>;</code></li>
<li>Instead of using the long message declaration macros, consider defining your own. Maybe something like <code>#define C_MSG_1 DYNAMIX_CONST_MESSAGE_1</code></li>
<li>Prefer using <code>object_type_template</code>-s instead of mutating each new object in the same fashion.</li>
<li>Prefer using <code>same_type_mutator</code> when mutating multiple objects of the same type.</li>
<li>If you have some messages that are valid for <em>all</em> objects in your system, instead of adding them to a mixin present in every object, consider having some stand-alone functions where your first parameter is <code><a class="el" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a>&amp;</code>. They will be indistinguishable from messages.</li>
<li>If you have multicast logic that needs to stop after a success in any of the message implementations in an object, have your messages return <code>bool</code> and then use the <code>boolean_or</code> combinator. It will stop the message execution on the first <code>true</code>.</li>
</ul>
<h2>Common features in objects </h2>
<p>When developing software with DynaMix, you'll often find yourself needing some set of features added to every object. While adding the same mixin to all objects (be it manually or by a mutation rule) is an option, a much cleaner solution is to just use your own class for objects, which iherits from <code><a class="el" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a></code>. For such a case consider adding your own versions of the <code>dm_this</code> and <code>dynamix::object_of</code> functions to return your own object type.</p>
<p>Subclassing <code><a class="el" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a></code> instead of having a mixin common to <em>all</em> objects is the preferred way to accomplish shared object features. Apart from it being cleaner and easier to read, it's also a bit better in performance, because it will save you the indirections from getting to those features.</p>
<p>Try using a mixin common to all objects only it these cases:</p><ul>
<li>When it contains functionality which can be overriden by other mixins (for such cases default message implementations is also something to consider).</li>
<li>When the functionality is not a core piece of the software but instead comes in an optional plug-in.</li>
</ul>
<p>Here is an example solution:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>my_object : <span class="keyword">public</span> <a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// all objects in this software have id and name</span></div><div class="line">    std::string name;</div><div class="line">    <span class="keywordtype">int</span> id;</div><div class="line"></div><div class="line">    <span class="comment">// hide implementations from object to avoid slicing when copying</span></div><div class="line">    <span class="comment">// copy your own data in these functions too</span></div><div class="line">    my_object <a class="code" href="classdynamix_1_1object.html#ad853b6f2f29cea857d8b8d8d0eb0485a">copy</a>() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="classdynamix_1_1object.html#adf5cfe19ba91115d0512a94697320c2f">copy_from</a>(<span class="keyword">const</span> my_object&amp; o);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="classdynamix_1_1object.html#aff534c25d83fc9ea7ca94d1a413033be">copy_matching_from</a>(<span class="keyword">const</span> my_object&amp; o);</div><div class="line">};</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">template &lt;<span class="keyword">typename</span> Mixin&gt;</div><div class="line">my_object* my_object_of(Mixin* m)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>my_object*<span class="keyword">&gt;</span>(<a class="code" href="mixin_8hpp.html#ac03e7d1c78cf3f0f4a14187bd188eadf" title="gets the object of a mixin ">dynamix::object_of</a>(m));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Mixin&gt;</div><div class="line"><span class="keyword">const</span> my_object* my_object_of(<span class="keyword">const</span> Mixin* m)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>my_object*<span class="keyword">&gt;</span>(<a class="code" href="mixin_8hpp.html#ac03e7d1c78cf3f0f4a14187bd188eadf" title="gets the object of a mixin ">dynamix::object_of</a>(m));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#define my_bm_this my_object_of(this)</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">my_object o;</div><div class="line">mutate(o)</div><div class="line">    .add&lt;my_mixin&gt;()</div><div class="line">    .add&lt;other_mixin&gt;();</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">void my_mixin::foo()</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> own_object_id = my_bm_this-&gt;id;</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="common_mixin_parent"></a>
Mixins with a common parent </h2>
<p>Sometimes you will feel the need to have mixins with a common parent. Most likely this will happen when you want to define two different mixins that share some common functionality. Moving the shared functionality in the same common parent is a good idea and DynaMix will work exactly the same way if you do this. However there is a pitfall in this case. It happens when you have multiple inheritance. Due to the special nature in which the library arranges the memory internally, if a mixin type has more than one parent, using <code>dm_this</code> in some of those parents might lead to crashes.</p>
<p>More precisely, when the library allocates memory for a mixin type, it allocates a buffer that is slightly bigger than needed and puts the pointer to the owning object at its front. What <code>dm_this</code> does is actually an offset from <code>this</code> with the appropriate number of bytes for <code>object*</code>. So if a parent of your mixin type, other than the first, calls <code>dm_this</code>, it will end up returning an invalid pointer to the owning object.</p>
<p>To be able to have parents, other than the first, with access to the owning object we suggest that you create a pure virtual function that gets it from the actual mixin type.</p>
<p>Say <code>virtual object* get_dm_object() = 0;</code> in the parents, which is implemented in the child class (the actual mixin defined with <code>DYNAMIX_DEFINE_MIXIN</code>) by simply <code>return dm_this</code>.</p>
<p>Of course there are other ways to accomplish this, for example with CRTP, but the virtual function is probably the cleanest and safest one.</p>
<h1><a class="anchor" id="common_problems"></a>
Common problems and solutions </h1>
<h2><a class="anchor" id="compiler_errors"></a>
Compiler errors </h2>
<ul>
<li>No overload of <code>_dynamix_get_mixin_type_info</code> supports the type<ul>
<li>Problem: In your code you're referring to a mixin, that the library cannot recognize as such. This could be caused by a mutation, or by calling <code>object::get</code> or <code>object::has</code>.</li>
<li>Solution: Make sure you've spelled the name of the mixin correctly. Make sure the line that produces the error has visibility to the declaration of this mixin (by <code>DYNAMIX_DECLARE_MIXIN</code>)</li>
</ul>
</li>
<li>No overload of <code>_dynamix_get_mixin_feature</code> supports the type<ul>
<li>Problem: You're calling <code>object::implements</code> with a message that cannot be recognized as such.</li>
<li>Solution: Make sure you've spelled the message name correctly. Make sure you've added the <code>_msg</code> suffix to the message.</li>
</ul>
</li>
<li>No overload of <code>_dynamix_register_mixin_feature</code> supports the type</li>
<li>...or no overload of operator <code>&amp;</code> supports the type<ul>
<li>Problem: You're adding a mixin feature to the feature list in <code>DYNAMIX_DEFINE_MIXIN</code> that cannot be recognized as such</li>
<li>Solution: If it's a message, check that you've added the <code>_msg</code> suffix. If it's an allocator, make sure it's derived from the <code>mixin_allocator</code> class</li>
</ul>
</li>
<li>Redefinition of _dynamix_get_mixin_feature<ul>
<li>Problem: You're defining two messages with <code>DYNAMIX_DEFINE_MESSAGE</code> that have same name in the same file.</li>
<li>Solution: Declare the messages as overloads with <code>DYNAMIX_xxx_MESSAGE_N_OVERLOAD</code>. Define the overloads.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="linker_errors"></a>
Linker errors </h2>
<p>Undefined reference (mentioned below) will be reported as an "unresolved
external symbol" in Visual C++.</p>
<ul>
<li>Undefined reference to <code>_dynamix_get_mixin_type_info</code><ul>
<li>Problem 1: A type has been declared as a mixin, but hasn't been defined</li>
<li>Solution 1: Define the mixin with <code>DYNAMIX_DEFINE_MIXIN</code></li>
<li>Problem 2: A mixin is being used from a dynamic library and hasn't been exported correctly.</li>
<li>Solution 2: Declare the mixin properly as <code>DYNAMIX_DECLARE_EXPORTED_MIXIN</code></li>
</ul>
</li>
<li>Undefined references to <code>_dynamix_register_mixin_feature</code> and <code>_dynamix_get_mixin_feature</code><ul>
<li>Problem 1: A message has been declared but not defined.</li>
<li>Solution 1: Define the message with <code>DYNAMIX_DEFINE_MESSAGE</code></li>
<li>Problem 2 : A message is being used from a dynamic library and hasn't been exported correctly.</li>
<li>Solution 2: Declare the message properly as <code>DYNAMIX_EXPORTED_xxx_MESSAGE_N</code></li>
</ul>
</li>
<li>Multiple references to <code>_dynamix_register_mixin_feature</code> and <code>_dynamix_get_mixin_feature</code><ul>
<li>Problem: Two messages have been defined with the same name and different arguments.</li>
<li>Solution: Declare the messages as overloads with <code>DYNAMIX_xxx_MESSAGE_N_OVERLOAD</code></li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="runtime_errors"></a>
Runtime errors </h2>
<p>The exceptions the library may throw, what causes them, and how to fix them can be found in the reference. Besides them, these may also occur:</p>
<ul>
<li>Assertion fails in <code><a class="el" href="domain_8hpp.html">domain.hpp</a></code>: "you have to increase the maximum number of
mixins"<ul>
<li>Problem: The maximum number of registered mixins supported by the library has been surpassed.</li>
<li>Solution: You have to increase the value of <code>DYNAMIX_MAX_MIXINS</code> in the file <code><a class="el" href="config_8hpp.html">config.hpp</a></code> of the library and then rebuild it.</li>
</ul>
</li>
<li>Assertion fails in <code>domain.cpp</code>: "you have to increase the maximum number of
messages"<ul>
<li>Problem: The maximum number of registered messages supported by the library has been surpassed.</li>
<li>Solution: You have to increase the value of <code>DYNAMIX_MAX_MESSAGES</code> in the file <code><a class="el" href="config_8hpp.html">config.hpp</a></code> of the library and then rebuild it. </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Nov 11 2018 10:50:39 for DynaMix by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
