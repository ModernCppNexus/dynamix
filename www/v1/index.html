<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>DynaMix: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynaMix
   &#160;<span id="projectnumber">1.3.7</span>
   </div>
   <div id="projectbrief">A new take on polymorphism in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#abstract">Abstract </a><ul><li class="level2"><a href="#other_mixin">Other meanings of &quot;mixin&quot; in C++ </a></li>
<li class="level2"><a href="#other_lang">Other meanings of &quot;mixin&quot; in other languages </a></li>
<li class="level2"><a href="#look_feel">Basic look and feel of the code with DynaMix </a></li>
</ul>
</li>
<li class="level1"><a href="#features">List of features </a></li>
<li class="level1"><a href="#when_to_use">When (and when not) to use DynaMix </a></li>
<li class="level1"><a href="#comparisons">Comparisons </a><ul><li class="level2"><a href="#multiple_inh">Comparison with multiple inheritance </a></li>
<li class="level2"><a href="#ecs">DynaMix as an entity-component-system </a></li>
<li class="level2"><a href="#com">Comparison with COM </a></li>
<li class="level2"><a href="#traits">Comparison with traits </a></li>
<li class="level2"><a href="#ruby">Comparison with Ruby mixins </a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><div class="image">
<img src="logo.png" alt="logo.png"/>
</div>
<h1><a class="anchor" id="abstract"></a>
Abstract </h1>
<p>DynaMix is a library which allows the composition and modification of polymorphic objects at run time. Objects are constructed from building blocks called "mixins" enabling an effect similar to multiple inheritance, while allowing the client code to remain oblivious to the actual composition of the objects.</p>
<p>A take on the <a href="http://en.wikipedia.org/wiki/Composition_over_inheritance">Composition over inheritance</a> technique, the result resembles the <a href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_modules.html">mixins in Ruby</a>. It can also be compared to the <a href="http://archive.eiffel.com/doc/online/eiffel50/intro/language/tutorial-10.html">inheritance in Eiffel</a> or the traits in <a href="http://selflanguage.org/_static/tutorial/Language/Prototypes/Organizing.html">Self</a>, <a href="http://www.scala-lang.org/node/126">Scala</a>, <a href="http://php.net/manual/en/language.oop5.traits.php">PHP</a>, <a href="https://en.wikipedia.org/wiki/Trait_(computer_programming)">and many others</a>, or the <a href="http://doc.perl6.org/language/objects#Roles">roles in Perl</a>.</p>
<p>This is given while also having full abstraction between the interface and the definition of types &ndash; a problem often given as the motivation for the <a href="http://www.drdobbs.com/cpp/making-pimpl-easy/205918714">PIMPL idiom</a>.</p>
<p>In short, <em>DynaMix is an alternative way to accomplish polymorphism</em>. It is a means to create a project's <em>architecture</em>, rather than implement its purpose.</p>
<p>The library uses the type <code><a class="el" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a></code> as a placeholder, whose instances can be extended with existing classes (mixins), thus providing a particular instance with the functionality of all those types. Accessing the newly formed type's interface is made through messages &ndash; stand-alone functions generated by the library, which can be thought of as methods.</p>
<p>DynaMix focuses on maximal performance and minimal memory overhead.</p>
<h2><a class="anchor" id="other_mixin"></a>
Other meanings of "mixin" in C++ </h2>
<p>The term "Mixin" is not to be confused with another meaning, popular in C++, namely <a href="http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP mixins</a>. This particular use of CRTP in this document shall henceforth be referred to as "traits", as the exact same functionality is called "traits" in many other languages.</p>
<h2><a class="anchor" id="other_lang"></a>
Other meanings of "mixin" in other languages </h2>
<p>In D <a href="http://dlang.org/mixin.html">the term mixin</a> exists and <code>mixin</code> is a keyword. It is a compile time feature, that has some similarities with the macros in C and C++, and none at all with the mixins in DynaMix. It is a completely different concept.</p>
<h2><a class="anchor" id="look_feel"></a>
Basic look and feel of the code with DynaMix </h2>
<p>Here is a very small and incomplete example of what your code may look like if you use the library:</p>
<div class="fragment"><div class="line"><span class="comment">// assuming my_objects.get_ally(0); is a way to get an ally to the</span></div><div class="line"><span class="comment">// main character in a game</span></div><div class="line"><a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a>&amp; obj = my_objects.get_ally(0);</div><div class="line"></div><div class="line"><span class="comment">// now let&#39;s make the object think some positive thoughts about the</span></div><div class="line"><span class="comment">// main character</span></div><div class="line"></div><div class="line">think(obj); <span class="comment">// C++ doesn&#39;t allow us to have obj.think().</span></div><div class="line">            <span class="comment">// DynaMix&#39;s messages are standalone functions</span></div><div class="line"></div><div class="line"><span class="comment">// object composition</span></div><div class="line"><a class="code" href="classdynamix_1_1single__object__mutator.html">dynamix::mutate</a>(obj)</div><div class="line">    .add&lt;flying_creature&gt;();</div><div class="line"></div><div class="line"><span class="comment">// object can now respond to fly()</span></div><div class="line"></div><div class="line">fly(obj); <span class="comment">// ...instead of obj.fly()</span></div><div class="line"></div><div class="line"><span class="comment">// object mutation</span></div><div class="line"><a class="code" href="classdynamix_1_1single__object__mutator.html">dynamix::mutate</a>(obj)</div><div class="line">    .remove&lt;ally&gt;()</div><div class="line">    .add&lt;enemy&gt;();</div><div class="line"></div><div class="line">think(obj); <span class="comment">// the same object now thinks negative thoughts about the main</span></div><div class="line">            <span class="comment">// character, since it&#39;s no longer an ally, but an enemy</span></div></div><!-- fragment --><p>For a more detailed, working example see <a href="basic.html">the basic usage tutorial</a>.</p>
<h1><a class="anchor" id="features"></a>
List of features </h1>
<ul>
<li>Compose objects from mixins at run time</li>
<li>Physically separate interface and implementation</li>
<li>Non-intrusive &ndash; mixins don't need to have a common parent or any special code inside</li>
<li>No external dependencies other than the standard library</li>
<li>Fast polymorphic calls &ndash; comparable to <code>std::function</code></li>
<li>Mutate "live" objects by changing their composition at run time</li>
<li>Have multicast messages, which are handled by many mixins within an object</li>
<li>Possibility to have custom allocators to finely tune the memory and aim for cache-locality for critical parts of the code</li>
<li>Ability to have dynamic libraries that can enrich or modify objects, without modifying (or even rebuilding) the executable.</li>
<li>Thread safe message calls &ndash; as thread safe as the underlying methods.</li>
</ul>
<h1><a class="anchor" id="when_to_use"></a>
When (and when not) to use DynaMix </h1>
<p>The more complex your objects are, the more beneficial it will be to use the library. Pieces of software that typically have very complex objects include games (especially role-playing ones or strategies), CAD systems, enterprise systems, UI libraries, and more.</p>
<p>As a general rule of thumb: if you have complex polymorphic objects, DynaMix is a good choice.</p>
<p>We should emphasize on the polymorphism. In many very high-performance systems polymorphism is avoided at the cost of code that is (at least somewhat) harder to write and maintain (this is most often the case with high-end games). Since such systems will try to "squeeze" every possible piece of processing power out of the CPU, cache locality and lack of cache misses are critical in some parts of their code. As is the case with all instances of polymorphism, including C++ virtual methods and <code>std::function</code>, uses of DynaMix's features will almost certainly lead to cache misses. Of course, you may still rely on the library in other parts of your code, like the business (or gameplay) logic. For more information about the library performance, see the <a href="advanced.html#performance">Performance section</a>.</p>
<p>Of course, small projects with simple objects, even if they are polymorphic, may end up not finding any particular benefits in using the library, since their size makes them fast to compile and easy to maintain as they are. If a piece of software can be created in a couple of days, by one or two programmers, there will hardly be any need for DynaMix.</p>
<h1><a class="anchor" id="comparisons"></a>
Comparisons </h1>
<h2><a class="anchor" id="multiple_inh"></a>
Comparison with multiple inheritance </h2>
<p>The closest thing to DynaMix that C++ can offer out of the box is multiple inheritance. A <code><a class="el" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a></code> composed of some mixins, can be thought of as an instance of an empty class that's derived from these classes &ndash; the object's interface will be equal to the union of the interfaces of its mixins, and it will internally instantiate them.</p>
<p>Here's a comprehensive list of the most important differences between DynaMix and C++ multiple inheritance:</p>
<ul>
<li><b>No combinatorial explosion of types</b>: you compose types at runtime, and don't need to explicitly list all possible combinations of building-block types.</li>
<li><b>No type-bound interfaces</b>: since the interface is physically separated from the implementation (or type), you don't need to have a single class implement an interface. You could separate it between multiple classes or combine interfaces in a single class.</li>
<li><b>Live object mutation</b>: change the interface and/or implementation of messages in an object at runtime.</li>
<li><b>Natural common reference</b>: in order to have containers of your objects composed by multiple inheritance, you need to define a "master type" from which all parents need to be derived by virtual inheritance. Such a type would be a coupling "focal point" and would need to be frequently changed while you develop your software. In DynaMix this is a no-issue, since all objects in the library are of type <code><a class="el" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a></code>.</li>
</ul>
<p>However, even-though compared to other libraries that have similar features, DynaMix is one of the fastest and with the least memory overhead, using the library comes with some inevitable downsides when compared with plain multiple inheritance:</p>
<ul>
<li><b>No compile-time type</b>: An object derived from, say, <code>foo</code> and <code>bar</code> can implicitly be cast to <code>foo</code> or <code>bar</code>. Since the library uses a placeholder type &ndash; <code><a class="el" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a></code> &ndash; implicit casts to any of its mixins are impossible. That aside, the hypothetical object from above will receive all of the methods from foo and bar, but while this is true for the <code><a class="el" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a></code> with such mixins, a compilation error cannot be generated if a message is called that the object can't handle. A runtime error will be generated instead, which is the norm in similar libraries, but is harder to catch and debug than it is with plain multiple inheritance.</li>
<li><b>Memory overhead per type</b>: Each unique combination of mixins is internally represented by a type, which has type metadata &ndash; for example an internal alternative to a virtual table. The type metadata can take up to two kilobytes of memory. Unless a type is instantiated its metadata won't be created, but still if you expect to have a huge variety of types, you may want to keep this in mind. Of course systems that are expected to have thousands of different object types, usually wouldn't care about a couple of extra megabytes of memory, but it could happen.</li>
<li><b>Memory overhead per object</b>: An instance of an empty class that has multiple parents takes up memory equal to the sizes of all of its parents. This is inevitable. A <code>dynamix::objects</code> naturally takes up the same amount plus an additional pointer for the type metadata, plus N pointers used for the special <code>dm_this</code> pointer, where N is equal to the number of mixins within. So, in short, the memory overhead of an object composed on N mixins, is N+1 times <code>sizeof(intptr_t)</code> ((N+1) * 8 bytes on a 64 bit system).</li>
<li><b>Speed of message calls</b>: A message call is slower than a regular non-virtual method call. Exactly how much is very hard to estimate, since this depends very much on cache locality, but a message call can easily be compared to a <code>std::function</code> call in terms of speed, which in most (but not all) cases is a negligible overhead.</li>
</ul>
<h2><a class="anchor" id="ecs"></a>
DynaMix as an entity-component-system </h2>
<p>If you're familiar with entity-component-systems, one way of looking at at the library is as if it is one of those, and indeed, it has many features that are characteristic for such systems. More specifically the Interface to Component pattern</p>
<p>If you're not familiar with entity-component-systems, you might want to check out the <a href="appendix.html#aecs">appendix entry</a> on them.</p>
<p>Here's how DynaMix is like an Interface to Component ECS:</p>
<ul>
<li><code><a class="el" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a></code> can be interpreted as an entity in an ECS. It's just an empty class, that needs to be "built" from mixins.</li>
<li>consequently mixins can be thought of as components. You use mixins to build objects just as you use components to build entities.</li>
<li>As with any ECS, you can mutate objects by adding/removing/substituting mixins.</li>
</ul>
<p>However, DynaMix is not strictly an ECS. Here's a list of the differences.</p>
<ul>
<li>It is non-intrusive: Mixins don't need to inherit from a common parent, nor do you need to change the code of a class to "turn it into" a mixin.</li>
<li>Instead of classes with pure virtual methods, messages are used to represent the functional interface of mixins, and through that &ndash; of objects.</li>
<li>Because of the previous two differences, <code><a class="el" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a></code>-s can be (and are) completely oblivious to what kinds of mixins there may be, allowing you to truly, physically separate a program's subsystems. The entity in an ECS on the other hand, usually has at least some knowledge of all the possible component types (like the top level parent classes, for example).</li>
<li>Some entity-component-systems allow several entities to point to the same instance of a component. This is not possible in DynaMix. A mixin instance is bound to an object instance</li>
<li>Some entity-component-systems allow an entity to contain several instances of the same component type. This too is not possible in DynaMix. An object can have either zero or one instances of a given mixin type.</li>
</ul>
<p>Note that some data structures, sometimes called entity-component-systems, are not used to create and manage polymorphic objects, but instead are used to bind a strictly predefined set of concrete components to the same entity for a very performance intensive piece of software. The components are used by different subsystems, that require them to be aligned in dense arrays for faster processing, without cache misses. As we mentioned before, DynaMix isn't designed for such cases, and while in terms of design and ease of use, it is a better choice than such an approach, it cannot help you in their main goal. Still, a non-polymorphic ECS and DynaMix can be (and have been) used together in a signle piece of software where DynaMix is used in the business logic subsystem, while the performance critical low-level parts of the software make use of a non-polymorphic ECS.</p>
<h2><a class="anchor" id="com"></a>
Comparison with COM </h2>
<p>There are indeed similarities between DynaMix and Microsoft <a href="https://en.wikipedia.org/wiki/Component_Object_Model">Component Object Model</a>. DynaMix object are composed out of mixins much like COM's objects are composed from components. Indeed many patterns in DynaMix might be familiar to programmers familiar with COM. The notable differences are:</p>
<ul>
<li>DynaMix has <a href="glossary.html#multicast">multicasts</a></li>
<li>With DynaMix there are no interfaces per se. The messages are standalone functions and a mixin implements an arbitrary combination of them.</li>
<li>Removing a mixin from an object in restores the object's previous state</li>
<li>DynaMix objects feel more like idiomatic C++ objects: They can be moved and copied and they have destructors instead of relying on a <code>Release</code> method.</li>
</ul>
<h2><a class="anchor" id="traits"></a>
Comparison with traits </h2>
<p>As mentioned above DynaMix is similar to a feature of many other languages, called "traits". The exact same feature can be mimicked in C++ with CRTP. You may have heard the term "mixin" being mentioned in a C++ context before. It is very likely that what was meant was this CRTP style of creating types from existing ones.</p>
<p>Indeed, at least superficially, both DynaMix and said traits are very similar as both are used to create new types by combining existing ones, while also solving one of the problems of plain old multiple inheritance - the communication between the different components that comprise the object.</p>
<p>However much of the multiple inheritance problems remain:</p>
<ul>
<li>Types composed of traits are static. Most languages (including C++ using the aforementioned mimic) don't allow you to change an object's type.</li>
<li>There is still a combinatorial explosion of types: each possible combination needs to be explicitly coded.</li>
<li>In strongly typed languages, like C++, there is still the problem of having a common interface to all objects.</li>
<li>In C++ you are bound to having the same compilation dependencies because of the header files that need to be included to compose types.</li>
</ul>
<p>DynaMix solves all of these problems.</p>
<h2><a class="anchor" id="ruby"></a>
Comparison with Ruby mixins </h2>
<p>If you're familiar with the <a href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_modules.html">mixins in Ruby</a>, perhaps you will find a lot of similarities between them and DynaMix.</p>
<p>Ruby's mixins can of course be used just like traits, however extending existing objects with modules is also allowed via <code>Object::extend</code>. This is almost exactly what DynaMix allows you to do. Indeed, Ruby has been a great inspiration for this library.</p>
<p>Still, barring the differences that arise from C++ being a strongly typed language, for a small amount of extra code DynaMix allows you to do much more:</p>
<ul>
<li><b>Removing mixins</b>: in Ruby, when you extend an object with a module, all functions that both object and the module have are permanently overridden in the object by their versions from the module. DynaMix allows you to temporarily mutate the object and then remove the mixin while restoring the object exactly to its former self.</li>
<li><b>Prioritize messages</b>: in DynaMix you can set priorities to the messages and thus when extending an object with a mixin, if a message is implemented by the object with a higher priority, even though it is also supplied by the mixin, in won't override the one already in the object.</li>
<li><b>Multicast messages</b>: in Ruby (as in almost every other language with a similar functionality) a method call leads to a piece of code, defined for that method. DynaMix allows you to have messages that are handled by more than one of mixins in an object. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Nov 11 2018 10:50:42 for DynaMix by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
