<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>DynaMix: Advanced Topics</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynaMix
   &#160;<span id="projectnumber">1.3.7</span>
   </div>
   <div id="projectbrief">A new take on polymorphism in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('advanced.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Advanced Topics </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#performance">Performance </a><ul><li class="level2"><a href="#msg_perf">Message performance </a></li>
<li class="level2"><a href="#mutation_perf">Mutation performance </a></li>
</ul>
</li>
<li class="level1"><a href="#thread_safety">Thread safety </a></li>
<li class="level1"><a href="#using_allocators">Using custom allocators </a></li>
<li class="level1"><a href="#more_msg_arity">Having messages with more arguments </a></li>
<li class="level1"><a href="#dynlibs">Shared libraries and program plugins </a></li>
<li class="level1"><a href="#serializing">Serializing objects </a></li>
<li class="level1"><a href="#impl_notes">Implementation notes </a><ul><li class="level2"><a href="#registration">Mixin and feature registration </a></li>
<li class="level2"><a href="#mix_msg_ids">Mixin and message id-s </a></li>
<li class="level2"><a href="#mut_type_info">Mutation and type information </a></li>
<li class="level2"><a href="#calling_msgs">Calling messages </a></li>
</ul>
</li>
<li class="level1"><a href="#why_macros">Macros rationale </a><ul><li class="level2"><a href="#why_mixin_macros">Mixin definition and declaration macros </a></li>
<li class="level2"><a href="#why_msg_macros">Message definition and declaration macros </a></li>
<li class="level2"><a href="#external_moc">External custom preprocessor </a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="performance"></a>
Performance </h1>
<h2><a class="anchor" id="msg_perf"></a>
Message performance </h2>
<p>The performance of messages is indeed slower than regular function calls and even virtual function calls. Even though a call's algorithmic complexity is still O(1), a number of memory indirections happen in order to call the actual method behind the message.</p>
<p>Unfortunately it's hard to estimate exactly how much slower the message call is. With perfect cache locality and compiler optimizations a message call will take several nanoseconds to execute on a modern CPU. It would be a bit slower than a virtual vall and about as fast as a <code>std::function</code> call.</p>
<p>Unfortunately perfect cache locality is hard to come by, and especially hard in polymorphic code. So, generally speaking if the programmer doesn't take special care to achieve cache locality for their object lists, a message call is about 2-3 times slower than a virtual method agaub about as fast a <code>std::function</code> call, which again can be called negligible.</p>
<p>As, we've mentioned before if cache locality is an absolutely critical feature for the desired performance, mixin messages, virtual calls, <code>std::function</code>, and other types of polymorphism will almost certainly be detrimental for this code, and the programmers are advised to do something else.</p>
<p>Here is the assembly generated by gcc 7.1 for <code>int(int)</code> message call:</p>
<div class="fragment"><div class="line">push    rbp</div><div class="line">push    rbx</div><div class="line">mov     rbx, rdi</div><div class="line">xor     edi, edi</div><div class="line">mov     ebp, esi</div><div class="line">sub     rsp, 8</div><div class="line">call    _dynamix_get_mixin_feature_fast(feature*)</div><div class="line">; <span class="keywordflow">if</span> not exported from a shared library, the lines from above can be</div><div class="line">; optimized away to an offset from rip with link time optimization</div><div class="line"></div><div class="line">; call table entry</div><div class="line">mov     rax, QWORD PTR [rax]</div><div class="line">mov     rcx, QWORD PTR [rbx]</div><div class="line">mov     esi, ebp</div><div class="line"></div><div class="line">; message data</div><div class="line">lea     rax, [rax+rax*2]</div><div class="line">mov     rdx, QWORD PTR [rcx+8208+rax*8]</div><div class="line"></div><div class="line">; mixin data</div><div class="line">mov     rax, QWORD PTR [rdx+8]</div><div class="line">mov     rax, QWORD PTR [rcx+rax*8]</div><div class="line"></div><div class="line">; prepare tailcall</div><div class="line">sal     rax, 4</div><div class="line">add     rax, QWORD PTR [rbx+8]</div><div class="line">mov     rdi, QWORD PTR [rax+8]</div><div class="line">mov     rax, QWORD PTR [rdx+16]</div><div class="line">add     rsp, 8</div><div class="line">pop     rbx</div><div class="line">pop     rbp</div><div class="line">jmp     rax ; tailcall to user code</div></div><!-- fragment --><h3>Message performance test</h3>
<p>The message performance test compares virtual method calls vs <code>std::function</code> calls vs DynaMix message calls.</p>
<p>For all tests a number of random objects of one of two possible types are generated. The <code>noop</code> test calls a function with no arguments and no body, measuring the time only. The <code>setter</code> test sets a member variable via a virtual setter function.</p>
<p>The multicast tests create random objects of one of three possible types, which all call three member polymorphic functions. Once again there's a <code>noop</code> test with empty functions with no arguments and <code>setter</code> test with virtual setter functions which set an integer.</p>
<p>In all example test the <code>std::function</code> implementation is chosen as a baseline and the baseline column is the performance compared to it.</p>
<p>Here are some sample test results:</p>
<ul>
<li>OS: Ubuntu 16.04</li>
<li>CPU: AMD FX X8 8150</li>
<li>Compiler: gcc 5.4.0</li>
<li>Compiler arguments: <code>-O3</code></li>
</ul>
<table class="doxtable">
<tr>
<th>Name (baseline is *) </th><th>Objects </th><th>Total ms </th><th>ns/op </th><th>Baseline</th><th>Ops/second  </th></tr>
<tr>
<td>virtual_noop </td><td>200000 </td><td>1.288 </td><td>6 </td><td>0.256 </td><td>155225270.7 </td></tr>
<tr>
<td>std_func_noop * </td><td>200000 </td><td>5.035 </td><td>25 </td><td>- </td><td>39725820.3 </td></tr>
<tr>
<td>msg_noop </td><td>200000 </td><td>3.118 </td><td>15 </td><td>0.619 </td><td>64151747.1 </td></tr>
<tr>
<td>virtual_setter </td><td>200000 </td><td>1.540 </td><td>7 </td><td>0.254 </td><td>129892565.9 </td></tr>
<tr>
<td>std_func_setter * </td><td>200000 </td><td>6.070 </td><td>30 </td><td>- </td><td>32951002.8 </td></tr>
<tr>
<td>msg_setter </td><td>200000 </td><td>4.509 </td><td>22 </td><td>0.743 </td><td>44354926.3 </td></tr>
<tr>
<td>(multi) virtual_noop </td><td>200000 </td><td>5.326 </td><td>26 </td><td>0.282 </td><td>37549680.6 </td></tr>
<tr>
<td>(multi) std_func_noop * </td><td>200000 </td><td>18.881 </td><td>94 </td><td>- </td><td>10592822.0 </td></tr>
<tr>
<td>(multi) msg_noop </td><td>200000 </td><td>7.760 </td><td>38 </td><td>0.411 </td><td>25774461.3 </td></tr>
<tr>
<td>(multi) virtual_setter </td><td>200000 </td><td>6.192 </td><td>30 </td><td>0.279 </td><td>32298656.6 </td></tr>
<tr>
<td>(multi) std_func_setter * </td><td>200000 </td><td>22.219 </td><td>111 </td><td>- </td><td>9001301.1 </td></tr>
<tr>
<td>(multi) msg_setter </td><td>200000 </td><td>8.877 </td><td>44 </td><td>0.400 </td><td>22529979.2 </td></tr>
</table>
<ul>
<li>OS: Windows 10</li>
<li>CPU: Intel Core i7 @ 2.3GHz</li>
<li>Compiler: Visual C++ 14 (2015) Update 3</li>
<li>Debug compilation parameters: Standard (<code>/Od /EHsc /RTC1 /MDd /ZI</code>)</li>
<li>Compiler arguments: <code>/O2 /Ob2 /MD</code></li>
</ul>
<table class="doxtable">
<tr>
<th>Name (baseline is *) </th><th>Objects </th><th>Total ms </th><th>ns/op </th><th>Baseline</th><th>Ops/second  </th></tr>
<tr>
<td>virtual_noop </td><td>200000 </td><td>0.930 </td><td>4 </td><td>0.204 </td><td>215059082.1 </td></tr>
<tr>
<td>std_func_noop * </td><td>200000 </td><td>4.549 </td><td>22 </td><td>- </td><td>43965397.5 </td></tr>
<tr>
<td>msg_noop </td><td>200000 </td><td>2.841 </td><td>14 </td><td>0.625 </td><td>70391577.8 </td></tr>
<tr>
<td>virtual_setter </td><td>200000 </td><td>1.212 </td><td>6 </td><td>0.146 </td><td>165015820.9 </td></tr>
<tr>
<td>std_func_setter * </td><td>200000 </td><td>8.302 </td><td>41 </td><td>- </td><td>24089393.8 </td></tr>
<tr>
<td>msg_setter </td><td>200000 </td><td>4.561 </td><td>22 </td><td>0.549 </td><td>43853542.3 </td></tr>
<tr>
<td>(multi) virtual_noop </td><td>200000 </td><td>4.115 </td><td>20 </td><td>0.331 </td><td>48604622.1 </td></tr>
<tr>
<td>(multi) std_func_noop * </td><td>200000 </td><td>12.443 </td><td>62 </td><td>- </td><td>16073708.9 </td></tr>
<tr>
<td>(multi) msg_noop </td><td>200000 </td><td>5.343 </td><td>26 </td><td>0.429 </td><td>37429695.3 </td></tr>
<tr>
<td>(multi) virtual_setter </td><td>200000 </td><td>5.581 </td><td>27 </td><td>0.306 </td><td>35837457.8 </td></tr>
<tr>
<td>(multi) std_func_setter * </td><td>200000 </td><td>18.236 </td><td>91 </td><td>- </td><td>10967410.0 </td></tr>
<tr>
<td>(multi) msg_setter </td><td>200000 </td><td>9.913 </td><td>49 </td><td>0.544 </td><td>20175710.3 </td></tr>
</table>
<h3>Optimizing message calls</h3>
<p>The stand-alone functions generated for messages typically have an <code>if</code> statement in them. It's there so as to throw an exception if none of the mixins in an object implements the message. If you disable the library's exceptions those <code>if</code>-s will be converted to <code>assert</code>-s (which in non-debug compilations are simply ignored).</p>
<p>If you don't want to recompile the library with exceptions disabled, or if you just want all other exceptions, but not these, you can disable the throwing of exceptions from the message functions if you define <code>DYNAMIX_NO_MSG_THROW</code> <em>before</em> including the DynaMix headers.</p>
<p>Note that if you disable the exceptions from the message functions, calling a message on an object that doesn't implement it, will certainly lead to undefined behavior and crashes.</p>
<p>Also have in mind, that removing the 'if'-s will improve the performance by only a small amount of nanoseconds per message call on a modern CPU. Situations where such a thing could be significant should be very very rare.</p>
<h2><a class="anchor" id="mutation_perf"></a>
Mutation performance </h2>
<p>An object mutation can be a relatively slow operation.</p>
<p>Every mutation will invoke all mutation rules registered within the system. Their speed may vary and will depend on whether they end up changing the mutation or not. If they do change it, some allocation may take place. Even if they don't, each of them will be invoked by a virtual function and will have at least one 'if' check (possibly more, depending on the mutation rule).</p>
<p>If the mutation ends up creating a new type &ndash; a mixin combination that hasn't yet been met &ndash; this will also lead to the relatively slow process of initializing the internal data structures for that type. This will lead to some allocations and loops that generate the type's call table.</p>
<p>Even if the mutation doesn't generate a new type, it will have to find the existing one, which is a hash table lookup with key a bitset of size <code>DYNAMIX_MAX_MIXINS</code>.</p>
<p>Finally, the mutation will change the object (unless it happens to be an identity mutation &ndash; adding and removing nothing). To change it it will have to allocate new mixin data for it &ndash; an array of pointers to mixins, then deallocate any mixins being removed and allocate any mixins being added, and finally deallocate the old mixin data for the object.</p>
<h3>Optimizing mutations</h3>
<p>Using <code><a class="el" href="classdynamix_1_1object__type__template.html">dynamix::object_type_template</a></code> or <code><a class="el" href="classdynamix_1_1same__type__mutator.html">dynamix::same_type_mutator</a></code> will perform the first steps &ndash; the ones concerning the identification of the object's type &ndash; only once.</p>
<p>To reduce the allocations for the individual object's being mutated, you can add custom allocators to some of the mixins or to the entire domain.</p>
<h3>Mutations performance test</h3>
<p>The mutation performance test test creation of new objects and the mutation of existing ones.</p>
<ul>
<li><b>create_mutate</b> &ndash; Creation of objects with <code>dynamix::mutate</code>.</li>
<li><b>type_template</b> &ndash; Creation of objects with a <code><a class="el" href="classdynamix_1_1object__type__template.html">dynamix::object_type_template</a></code>.</li>
<li><b>type_template_alloc</b> &ndash; Mutation with a type template and a fast custom allocator.</li>
<li><b>mutation</b> &ndash; Mutation of objects with <code>dynamix::mutate</code>. Adding two mixins and removing one.</li>
<li><b>same_type_mutator</b> &ndash; The same mutation using <code><a class="el" href="classdynamix_1_1same__type__mutator.html">dynamix::same_type_mutator</a></code>.</li>
<li><b>same_type_mutator_alloc</b> &ndash; The same mutation with <code><a class="el" href="classdynamix_1_1same__type__mutator.html">dynamix::same_type_mutator</a></code> and a fast custom allocator.</li>
</ul>
<p>Here are some sample test results:</p>
<ul>
<li>OS: Ubuntu 16.04</li>
<li>CPU: AMD FX X8 8150</li>
<li>Compiler: gcc 5.4.0</li>
<li>Compiler arguments: <code>-O3</code></li>
</ul>
<table class="doxtable">
<tr>
<th>Name (baseline is *) </th><th>Objects </th><th>Total ms </th><th>ns/op </th><th>Baseline</th><th>Ops/second  </th></tr>
<tr>
<td>create_mutate * </td><td>10000 </td><td>9.810 </td><td>981 </td><td>- </td><td>1019320.5 </td></tr>
<tr>
<td>type_template </td><td>10000 </td><td>3.728 </td><td>372 </td><td>0.380 </td><td>2682686.2 </td></tr>
<tr>
<td>type_template_alloc </td><td>10000 </td><td>2.163 </td><td>216 </td><td>0.220 </td><td>4623247.0 </td></tr>
<tr>
<td>mutation * </td><td>10000 </td><td>8.311 </td><td>831 </td><td>- </td><td>1203170.2 </td></tr>
<tr>
<td>same_type_mutator </td><td>10000 </td><td>2.944 </td><td>294 </td><td>0.354 </td><td>3397164.9 </td></tr>
<tr>
<td>same_type_mutator_alloc </td><td>10000 </td><td>1.336 </td><td>133 </td><td>0.161 </td><td>7486296.3 </td></tr>
</table>
<ul>
<li>OS: Windows 10</li>
<li>CPU: Intel Core i7 @ 2.3GHz</li>
<li>Compiler: Visual C++ 14 (2015) Update 3</li>
<li>Debug compilation parameters: Standard (<code>/Od /EHsc /RTC1 /MDd /ZI</code>)</li>
<li>Compiler arguments: <code>/O2 /Ob2 /MD</code></li>
</ul>
<table class="doxtable">
<tr>
<th>Name (baseline is *) </th><th>Objects </th><th>Total ms </th><th>ns/op </th><th>Baseline</th><th>Ops/second  </th></tr>
<tr>
<td>create_mutate * </td><td>10000 </td><td>16.103 </td><td>1610 </td><td>- </td><td>620993.2 </td></tr>
<tr>
<td>type_template </td><td>10000 </td><td>5.468 </td><td>546 </td><td>0.340 </td><td>1828722.2 </td></tr>
<tr>
<td>type_template_alloc </td><td>10000 </td><td>2.749 </td><td>274 </td><td>0.171 </td><td>3637850.5 </td></tr>
<tr>
<td>mutation * </td><td>10000 </td><td>10.333 </td><td>1033 </td><td>- </td><td>967747.5 </td></tr>
<tr>
<td>same_type_mutator </td><td>10000 </td><td>3.648 </td><td>364 </td><td>0.353 </td><td>2741181.5 </td></tr>
<tr>
<td>same_type_mutator_alloc </td><td>10000 </td><td>1.688 </td><td>168 </td><td>0.163 </td><td>5923647.7 </td></tr>
</table>
<h1><a class="anchor" id="thread_safety"></a>
Thread safety </h1>
<p>Some functionalities of the library are purposefully not thread-safe so as to avoid the synchronization overhead for users which don't need it. For those it is possible to implement thread-safety in the client code.</p>
<ul>
<li>Querying objects (say with <code>has</code>, <code>get</code>, or <code>implements</code>) is thread-safe.</li>
<li>Calling messages is thread-safe. As thread-safe as the underlying functions of course.</li>
<li>Copying objects is thread-safe. As thread-safe as the copy-constructors and assignment operators of the mixins in those objects.</li>
<li>Mutating different objects in different threads is thread-safe. <em>HOWEVER</em></li>
<li>Mutating the same object in multiple threads is <b>not</b> thread-safe. If you need this, you can subclass object and have a mutex within your class, which can be maintained by a mutation rule</li>
<li>Mutating objects in some threads, while calling messages to <em>other</em> objects in other threads is thread-safe. <em>HOWEVER</em></li>
<li>Mutating an object in one thread and calling messages for this object in another is <b>not</b> thread-safe and, alas, it's hard to accomplish. If you absolutely need this, our suggestion is to first add a mutex to each object by inheriting it. Second, lock/unlock it via mutation rules. And, third, define your own message macros, for your object type which also lock said mutex.</li>
</ul>
<h1><a class="anchor" id="using_allocators"></a>
Using custom allocators </h1>
<p>(For the complete, working source of this example see <a href="https://github.com/iboB/dynamix/blob/master/tutorial/allocators.cpp">allocators.cpp</a>)</p>
<p>DynaMix allows you to set custom allocators for the persistent pieces of memory the library may require.</p>
<p>The library allocates some memory on initialization, which happens at a global scope &ndash; before the entry point of a program. It also has some allocations which are for instances with a very short lifetime. Currently those are not covered by the allocators.</p>
<p>What you can control with the custom allocators is the new memory allocated for <code><a class="el" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a></code> instances - their internal mixin data. You can assign a global allocator to the library and you can also set individual allocators per mixin type.</p>
<p>First let's see how you can create a global allocator. Let's assume you have a couple of functions of your own that allocate and deallocate memory in some way specific to your needs:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span>* allocate(<span class="keywordtype">size_t</span> size);</div><div class="line"><span class="keywordtype">void</span> deallocate(<span class="keywordtype">char</span>* buffer);</div></div><!-- fragment --><p> To create a global allocator, you need to create a class derived from <code>domain_allocator</code> and override its virtual methods.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>custom_allocator : <span class="keyword">public</span> <a class="code" href="classdynamix_1_1domain__allocator.html">dynamix::domain_allocator</a></div><div class="line">{</div></div><!-- fragment --><p> The first two methods allocate a buffer for the mixin data pointers. Every object has pointers to its mixins within it. This is the array of such pointers. The class <code>domain_allocator</code> has a static constant member &ndash; <code>mixin_data_size</code> &ndash; which you should use to see the size of a single element in that array.</p>
<p>The methods also have arguments referring to the object for which the mixin data is being allocated. We won't be using it in this simple example.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">char</span>* alloc_mixin_data(<span class="keywordtype">size_t</span> count, <span class="keyword">const</span> <a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a>*)<span class="keyword"> override</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    <span class="keywordflow">return</span> allocate(count * mixin_data_size);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> dealloc_mixin_data(<span class="keywordtype">char</span>* ptr, <span class="keywordtype">size_t</span>, <span class="keyword">const</span> <a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a>*)<span class="keyword"> override</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    deallocate(ptr);</div><div class="line">}</div></div><!-- fragment --><p> The other two methods you need to overload allocate and deallocate the memory for an actual mixin class instance. As you may have already read, the buffer allocated for a mixin instance is bigger than needed because the library stores a pointer to the owning object immediately before the memory used by the mixin instance.</p>
<p>That's why this function is not as simple as the one for the mixin data array. It has to conform to the mixin (and also <code>object</code> pointer) alignment.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> std::pair&lt;char*, size_t&gt; alloc_mixin(<span class="keyword">const</span> <a class="code" href="classdynamix_1_1basic__mixin__type__info.html">dynamix::basic_mixin_type_info</a>&amp; info, <span class="keyword">const</span> <a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a>*)<span class="keyword"> override</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p> The users are strongly advised to use the static method <code>domain_allocator::mem_size_for_mixin</code>. It will appropriately calculate how much memory is needed for the mixin instance such that there is enough room at the beginning for the pointer to the owning object and the memory alignment is respected.</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> size = mem_size_for_mixin(info.<a class="code" href="classdynamix_1_1basic__mixin__type__info.html#a11a0c2b963dc5568cf3d7e8c9460c2cd" title="Size of the mixin type. ">size</a>, info.<a class="code" href="classdynamix_1_1basic__mixin__type__info.html#a5b05be1cdceb2852f4bf19f56eb90f21" title="Alignment of the mixin type. ">alignment</a>);</div><div class="line"><span class="keywordtype">char</span>* buffer = allocate(size);</div></div><!-- fragment --><p> After you allocate the buffer you should take care of the other return value - the mixin offset. It calculates the offset of the actual mixin instance memory within the buffer, such that there is room for the owning object pointer in before it and all alignments are respected.</p>
<p>You are encouraged to use the static method <code>domain_allocator::mixin_offset</code> for this purpose.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">size_t</span> offset = mixin_offset(buffer, info.<a class="code" href="classdynamix_1_1basic__mixin__type__info.html#a5b05be1cdceb2852f4bf19f56eb90f21" title="Alignment of the mixin type. ">alignment</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> std::make_pair(buffer, offset);</div><div class="line">}</div></div><!-- fragment --><p> The mixin instance deallocation method can be trivial</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> dealloc_mixin(<span class="keywordtype">char</span>* ptr, <span class="keywordtype">size_t</span>, <span class="keyword">const</span> <a class="code" href="classdynamix_1_1basic__mixin__type__info.html">dynamix::basic_mixin_type_info</a>&amp;, <span class="keyword">const</span> <a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a>*)<span class="keyword"> override</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    deallocate(ptr);</div><div class="line">}</div></div><!-- fragment --><p> To use the custom global allocator you need to instantiate it and then set it with <code>set_global_allocator</code>. Unlike the mutation rules, the responsibility for the allocator instance is yours. You need to make sure that the lifetime of the instance is at least as long as the lifetime of all objects in the system.</p>
<p>Unfortunately this means that if you have global or static objects, you need to create a new pointer that is, in a way, a memory leak. If you do not have global or static objects, it should be safe for it to just be a local variable in your program's entry point function.</p>
<div class="fragment"><div class="line">custom_allocator alloc;</div><div class="line"><a class="code" href="domain_8hpp.html#a995a8a1460e9ff8507af938e1aefa1c9" title="Sets an global allocator for all mixins and datas. ">dynamix::set_global_allocator</a>(&amp;alloc);</div></div><!-- fragment --><p> As we mentioned before, you can have an allocator specific for a mixin type.</p>
<p>A common case for such use is to have a per-frame allocator &ndash; one that has a preallocated buffer which is used much like a stack, with its pointer reset at the end of each simulation frame (or at the beginning each new one). Let's create such an allocator.</p>
<p>First, a mixin instance allocator is not necessarily bound to a concrete mixin type. You can have the same instance of such an allocator set for many mixins (which would be a common use of a per-frame allocator), but for our example let's create one that <em>is</em> bound to an instance. We will make it a template class because the code for each mixin type will be the same.</p>
<p>A mixin instance allocator needs to be derived from the class <code>mixin_allocator</code>. You then need to overload its two virtual methods which are exactly the same as the mixin instance allocation/deallocation methods in <code>domain_allocator</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Mixin&gt;</div><div class="line"><span class="keyword">class </span>per_frame_allocator : <span class="keyword">public</span> <a class="code" href="classdynamix_1_1mixin__allocator.html">dynamix::mixin_allocator</a></div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> NUM_IN_PAGE = 1000;</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> _num_allocations; <span class="comment">// number of &quot;living&quot; instances allocated</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> mixin_buf_size; <span class="comment">// the size of a single mixin instance buffer</span></div><div class="line">    vector&lt;char*&gt; _pages; <span class="comment">// use pages of data where each page can store NUM_IN_PAGE instances</span></div><div class="line">    <span class="keywordtype">size_t</span> _page_byte_index; <span class="comment">// index within a memory &quot;page&quot;</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> page_size; <span class="comment">// size in bytes of a page</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">    <span class="comment">// some way to obtain the instance</span></div><div class="line">    <span class="keyword">static</span> per_frame_allocator&amp; instance()</div><div class="line">    {</div><div class="line">        <span class="keyword">static</span> per_frame_allocator i;</div><div class="line">        <span class="keywordflow">return</span> i;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    per_frame_allocator()</div><div class="line">        : _num_allocations(0)</div><div class="line">        , mixin_buf_size(</div><div class="line">            mem_size_for_mixin(</div><div class="line">                sizeof(Mixin),</div><div class="line">                <a class="code" href="namespacestd.html" title="STL namespace. ">std</a>::alignment_of&lt;Mixin&gt;::value))</div><div class="line">        , page_size(mixin_buf_size * NUM_IN_PAGE)</div><div class="line">    {</div><div class="line">        new_memory_page();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> new_memory_page()</div><div class="line">    {</div><div class="line">        <span class="keywordtype">char</span>* page = <span class="keyword">new</span> <span class="keywordtype">char</span>[page_size];</div><div class="line">        _pages.push_back(page);</div><div class="line">        _page_byte_index = 0;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> std::pair&lt;char*, size_t&gt; <a class="code" href="classdynamix_1_1mixin__allocator.html#a73ac5296d23cb54f780696d641572ac4">alloc_mixin</a>(<span class="keyword">const</span> <a class="code" href="classdynamix_1_1basic__mixin__type__info.html">dynamix::basic_mixin_type_info</a>&amp; info, <span class="keyword">const</span> <a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a>*)<span class="keyword"> override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">if</span>(_page_byte_index == NUM_IN_PAGE)</div><div class="line">        {</div><div class="line">            <span class="comment">// if we don&#39;t have space in our current page, create a new one</span></div><div class="line">            new_memory_page();</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordtype">char</span>* buffer = _pages.back() + _page_byte_index * mixin_buf_size;</div><div class="line"></div><div class="line">        <span class="comment">// again calculate the offset using this static member function</span></div><div class="line">        <span class="keywordtype">size_t</span> offset = <a class="code" href="classdynamix_1_1mixin__allocator.html#a0dbae92a126753ed00f32275629d3f41">mixin_offset</a>(buffer, info.<a class="code" href="classdynamix_1_1basic__mixin__type__info.html#a5b05be1cdceb2852f4bf19f56eb90f21" title="Alignment of the mixin type. ">alignment</a>);</div><div class="line"></div><div class="line">        ++_page_byte_index;</div><div class="line">        ++_num_allocations;</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> std::make_pair(buffer, offset);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classdynamix_1_1mixin__allocator.html#a83c2c62a4e6fb0adeee2fcdd07542b38">dealloc_mixin</a>(<span class="keywordtype">char</span>* buf, <span class="keywordtype">size_t</span>, <span class="keyword">const</span> <a class="code" href="classdynamix_1_1basic__mixin__type__info.html">dynamix::basic_mixin_type_info</a>&amp; info, <span class="keyword">const</span> <a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a>*)<span class="keyword"> override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line"><span class="preprocessor">#if !defined(NDEBUG)</span></div><div class="line">        <span class="comment">// in debug mode check if the mixin is within any of our pages</span></div><div class="line">        <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; _pages.size(); ++i)</div><div class="line">        {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">char</span>* page_begin = _pages[i];</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">char</span>* page_end = page_begin + page_size;</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (buf &gt;= page_begin &amp;&amp; buf &lt; page_end)</div><div class="line">            {</div><div class="line">                found = <span class="keyword">true</span>;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// deallocating memory, which hasn&#39;t been allocated from that allocator</span></div><div class="line">        DYNAMIX_ASSERT(found);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        buf; <span class="comment">// to skip warning for unused parameter</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        <span class="comment">// no actual deallocation to be done</span></div><div class="line">        <span class="comment">// just decrement our living instances counter</span></div><div class="line"></div><div class="line">        --_num_allocations;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// function to be called once each frame that resets the allocator</span></div><div class="line">    <span class="keywordtype">void</span> reset()</div><div class="line">    {</div><div class="line">        DYNAMIX_ASSERT(_num_allocations == 0); <span class="comment">// premature reset</span></div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=1; i&lt;_pages.size(); ++i)</div><div class="line">        {</div><div class="line">            <span class="keyword">delete</span>[] _pages[i];</div><div class="line">        }</div><div class="line">        _pages.resize(1);</div><div class="line"></div><div class="line">        _page_byte_index = 0;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> Now this class can be set as a mixin allocator for a given mixin type. A side effect of the fact that it's bound to the type is that it keeps mixin instances in a continuous buffer. With some changes (to take care of potential holes in the buffer) such an allocator can be used by a subsystem that works through mixins relying on them being in a continuous buffer to avoid cache misses.</p>
<p>To illustrate a usage for our mixin allocator, let's imagine we have a game. If a character in our game dies, it will be destroyed at the end of the current frame and should stop responding to any messages. We can create a mixin called <code>dead_character</code> which implements all those the messages with a higher priority than the rest of the mixins. Since every object that has a <code>dead_character</code> mixin will be destroyed by the end of the frame, it will be safe to use the per-frame allocator for it.</p>
<p>First let's create the mixin class and sample messages:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>dead_character</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> die() {}</div><div class="line">    <span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line">DYNAMIX_MESSAGE_0(<span class="keywordtype">void</span>, die);</div><div class="line"><a class="code" href="message__macros_8hpp.html#a4ea78051262bb047d5127da21a2e7af0">DYNAMIX_DEFINE_MESSAGE</a>(die);</div><div class="line"><span class="comment">//...</span></div></div><!-- fragment --><p> Now we define the mixin so that it uses the allocator, we just need to add it with "`&amp;`" to the mixin feature list, just like we add messages. There are two ways to do so. The first one would be to do it like this: </p><pre class="fragment">DYNAMIX_DEFINE_MIXIN(dead_character, ... &amp; dynamix::priority(1, die_msg)
    &amp; dynamix::allocator&lt;per_frame_allocator&lt;dead_character&gt;&gt;());
</pre><p>This will create the instance of the allocator internally and we won't be able to get it. Since in our case we do care about the instance because we want to call its <code>reset</code> method, we could use an alternative way, by just adding an actual instance of the allocator to the feature list:</p>
<div class="fragment"><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(dead_character, <span class="comment">/*...*/</span> dynamix::priority(1, die_msg)</div><div class="line">    &amp; per_frame_allocator&lt;dead_character&gt;::instance());</div></div><!-- fragment --><p> If we share a mixin instance allocator between multiple mixins, the second way is also the way to go.</p>
<p>Now all mixin allocations and deallocations will pass through our mixin allocator:</p>
<div class="fragment"><div class="line"><a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a> o;</div><div class="line"></div><div class="line"><a class="code" href="classdynamix_1_1single__object__mutator.html">dynamix::mutate</a>(o)</div><div class="line">    .add&lt;dead_character&gt;();</div><div class="line"></div><div class="line"><a class="code" href="classdynamix_1_1single__object__mutator.html">dynamix::mutate</a>(o)</div><div class="line">    .remove&lt;dead_character&gt;();</div><div class="line"></div><div class="line"><span class="comment">// safe because we&#39;ve destroyed all instances of dead_character</span></div><div class="line">per_frame_allocator&lt;dead_character&gt;::instance().reset();</div></div><!-- fragment --><h1><a class="anchor" id="more_msg_arity"></a>
Having messages with more arguments </h1>
<p>Currently the maximum number of arguments you can have in a message is: </p><pre class="fragment">6
</pre><p>There simply is no message declaration macro for messages with more. If you need macros for messages with more arguments, you can do so, without having to rebuild the library.</p>
<p>In your DynaMix installation, in the <code>gen</code> directory you will see a file, named <code>arity</code>. It is a text file with a single number in it. Edit the file, setting the number to whichever value you need. Then run the script <code>gen_message_macros.rb</code> (you will need a Ruby interpreter to do so). It will generate the file <code>include/dynamix/gen/message_macros.hpp</code> with macros for messages with 0 to <em>arity</em> arguments.</p>
<p>If you use an include directory for DynaMix diferent from the one in your installation, you will have to manually copy the newly generated message macros file over the one you use.</p>
<h1><a class="anchor" id="dynlibs"></a>
Shared libraries and program plugins </h1>
<p>As long as the library itself is shared (<code>.dll</code> on Windows or <code>.so</code> on Unix or Linux) it's safe to use in an application that has shared libraries which use DynaMix.</p>
<p>An interesting thing which you can accomplish with the library is to have optional plugins &ndash; dynamic libraries that aren't linked with the executable but may or may not be present, and if they are, they are being loaded dynamically (with <code>LoadLibrary</code> or <code>dlopen</code>).</p>
<p>Such plugin may add a mutation rule for its special mixins, or export functions that mutate objects.</p>
<p>For example this may be very useful for an engineering CAD system that could potentially have many different optional plugins for its different needs. Say, a plugin that extends the buildings with electrical wiring could simply mutate objects, adding a mixin mixin called <code>electrical_wiring</code> that contains the appropriate functionality.</p>
<p>There is only one thing you need to remember when you're exporting mixins or messages from a dynamic library: to use the export macros: <code>DYNAMIX_DECLARE_EXPORTED_MIXIN</code> and <code>DYNAMIX_EXPORTED_xxx_MESSAGE_N</code>. They are exactly like their regular counterparts but for their first argument, which is the compiler specific export symbol (<code>__declspec(dllexport)</code> for Visual C++ or, say, <code>BOOST_SYMBOL_EXPORT</code> if you're using Boost).</p>
<p><a href="examples.html#multi_dll">One of the examples</a> that come with the library illustrates how you can have the two types of dynamic libraries &ndash; one which you link with, and one plugin.</p>
<h1><a class="anchor" id="serializing"></a>
Serializing objects </h1>
<p>(For the complete, working source of this example see <a href="https://github.com/iboB/dynamix/blob/master/tutorial/serialization.cpp">serialization.cpp</a>)</p>
<p>Of course dealing with objects in a complex system means also having some way to save and load them. Be it from a file, database, or through a network. We did mention serialization before in our examples but we never gave an example of how you can serialize <code><a class="el" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a></code>-s.</p>
<p>The main issue would be how to convert the object's type information to a string and then use this string to create an object with the same type information. As for the concrete serialization of the data within the mixins, this example will only offer a very naive approach. We don't recommend that you use such an approach for your mixins as it is not safe, and not backward compatible. We only use it here because it's very easy to write and the focus of this example is on the object type information.</p>
<p>Basically what we'll do here to save and load the data inside the mixins is rely on two multicast messages &ndash; <code>save</code> and <code>load</code> &ndash; which will have a given priority for each mixin. Thus ensuring the order of execution to be the same in loading as it is in saving. Each save and load method of the mixin type will assume it has the right data to save and load.</p>
<p>So, let's declare and define our messages.</p>
<div class="fragment"><div class="line">DYNAMIX_CONST_MULTICAST_MESSAGE_1(<span class="keywordtype">void</span>, save, ostream&amp;, out);</div><div class="line">DYNAMIX_MULTICAST_MESSAGE_1(<span class="keywordtype">void</span>, load, istream&amp;, in);</div><div class="line"></div><div class="line"><a class="code" href="message__macros_8hpp.html#a4ea78051262bb047d5127da21a2e7af0">DYNAMIX_DEFINE_MESSAGE</a>(save);</div><div class="line"><a class="code" href="message__macros_8hpp.html#a4ea78051262bb047d5127da21a2e7af0">DYNAMIX_DEFINE_MESSAGE</a>(load);</div></div><!-- fragment --><p> Now let's define some simple mixins. For this example we'll assume we're writing a company management system, which has a database of key individuals &ndash; employees and clients.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>person</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> set_name(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name) { _name = name; }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> save(ostream&amp; out) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> load(istream&amp; in);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> serialize_priority = 1;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">string</span> _name;</div><div class="line">};</div><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(person,</div><div class="line">    dynamix::priority(person::serialize_priority, save_msg)</div><div class="line">    &amp; dynamix::priority(person::serialize_priority, load_msg));</div><div class="line"></div><div class="line"><span class="keyword">class </span>employee</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> set_position(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; position) { _position = position; }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> save(ostream&amp; out) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> load(istream&amp; in);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> serialize_priority = 2;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">string</span> _position;</div><div class="line">};</div><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(employee,</div><div class="line">    dynamix::priority(employee::serialize_priority, save_msg)</div><div class="line">    &amp; dynamix::priority(employee::serialize_priority, load_msg));</div><div class="line"></div><div class="line"><span class="keyword">class </span>client</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> set_organization(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; position) { _organization = position; }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> save(ostream&amp; out) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> load(istream&amp; in);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> serialize_priority = 3;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">string</span> _organization;</div><div class="line">};</div><div class="line"><a class="code" href="mixin_8hpp.html#ae96d7f5e4580604c41e932d1937b1c14" title="defines a mixin ">DYNAMIX_DEFINE_MIXIN</a>(client,</div><div class="line">    dynamix::priority(client::serialize_priority, save_msg)</div><div class="line">    &amp; dynamix::priority(client::serialize_priority, load_msg));</div></div><!-- fragment --><p> Now let's declare the save and load functions for an object.</p>
<p>Because in this example they're stand-alone functions, like the messages, we can't just name them save and load, because they'll clash with the message functions defined by the message macros. So let's just name them <code>save_obj</code> and <code>load_obj</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> save_obj(<span class="keyword">const</span> <a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a>&amp; o, ostream&amp; out);</div><div class="line"><span class="keywordtype">void</span> load_obj(<a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a>&amp; o, istream&amp; in);</div></div><!-- fragment --><p> Assuming those functions are written and work correctly, we could write some code with them like this.</p>
<p>First we create some objects:</p>
<div class="fragment"><div class="line"><a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a> e;</div><div class="line"><a class="code" href="classdynamix_1_1single__object__mutator.html">dynamix::mutate</a>(e)</div><div class="line">    .add&lt;person&gt;()</div><div class="line">    .add&lt;employee&gt;();</div><div class="line"></div><div class="line">e.<a class="code" href="classdynamix_1_1object.html#a3ac87d5fed5273a72e40cff82fe0a2c5">get</a>&lt;person&gt;()-&gt;set_name(<span class="stringliteral">&quot;Alice Anderson&quot;</span>);</div><div class="line">e.<a class="code" href="classdynamix_1_1object.html#a3ac87d5fed5273a72e40cff82fe0a2c5">get</a>&lt;employee&gt;()-&gt;set_position(<span class="stringliteral">&quot;Programmer&quot;</span>);</div><div class="line"></div><div class="line"><a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a> c;</div><div class="line"><a class="code" href="classdynamix_1_1single__object__mutator.html">dynamix::mutate</a>(c)</div><div class="line">    .add&lt;person&gt;()</div><div class="line">    .add&lt;client&gt;();</div><div class="line"></div><div class="line">c.<a class="code" href="classdynamix_1_1object.html#a3ac87d5fed5273a72e40cff82fe0a2c5">get</a>&lt;person&gt;()-&gt;set_name(<span class="stringliteral">&quot;Bob Behe&quot;</span>);</div><div class="line">c.<a class="code" href="classdynamix_1_1object.html#a3ac87d5fed5273a72e40cff82fe0a2c5">get</a>&lt;client&gt;()-&gt;set_organization(<span class="stringliteral">&quot;Business Co&quot;</span>);</div></div><!-- fragment --><p> Then we save them to some stream:</p>
<div class="fragment"><div class="line">ostringstream out;</div><div class="line">save_obj(e, out);</div><div class="line">save_obj(c, out);</div></div><!-- fragment --><p> And finally use that stream to load those objects:</p>
<div class="fragment"><div class="line"><span class="keywordtype">string</span> data = out.str();</div><div class="line"></div><div class="line">istringstream in(data);</div><div class="line"></div><div class="line"><a class="code" href="classdynamix_1_1object.html" title="The main object class. ">dynamix::object</a> obj1, obj2;</div><div class="line">load_obj(obj1, in); <span class="comment">// loading Alice</span></div><div class="line">load_obj(obj2, in); <span class="comment">// loading Bob</span></div></div><!-- fragment --><p> Now, let's see what we need to do to make the code from above work as expected.</p>
<p>First let's write the save function.</p>
<p>To save the object we'll need to write the names of its mixins. You might know that mixins also have id-s, but saving id-s is not a safe operation as they are generated based on the global instantiation order. This means that different programs with the same mixins (like a client or a server), or even the same program after a recompilation, could end up generating different id-s for the same mixins.</p>
<p>To get the names of the mixins in an object we could use <code>object::get_mixin_names</code> and it's perfectly fine, but in order to make this example a bit more interesting, let's dive a bit into the library's internal structure.</p>
<p>If you've read the implementation notes or the debugging tutorial, you'll know that an object has a type information member which contains the mixin composition of the object in a <code>std::vector</code> called <code>_compact_mixins</code>. We'll use this vector to save the mixin names.</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> num_mixins = obj._type_info-&gt;_compact_mixins.size();</div><div class="line">out &lt;&lt; num_mixins &lt;&lt; endl; <span class="comment">// write the size</span></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;num_mixins; ++i)</div><div class="line">{</div><div class="line">    <span class="comment">// write each name</span></div><div class="line">    out &lt;&lt; obj._type_info-&gt;_compact_mixins[i]-&gt;name &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><p> After we've stored the object type information, we can now save the data within its mixins via the <code>save</code> message from above.</p>
<div class="fragment"><div class="line">save(obj, out);</div></div><!-- fragment --><p> That was it. Now let's move to the code of the <code>load_obj</code> function.</p>
<p>First we need to get the number of mixins we're loading. Let's do it in this simple fashion:</p>
<div class="fragment"><div class="line"><span class="keywordtype">string</span> line;</div><div class="line">getline(in, line);</div><div class="line"></div><div class="line"><span class="keywordtype">size_t</span> num_mixins = atoi(line.c_str());</div></div><!-- fragment --><p> Now we'll create an <code>object_type_template</code> which we'll use to store the loaded type and give it to a new object. The type template class (as all other mutator classes) has the method <code>add</code>. Besides the way you're used to calling it &ndash; <code>add&lt;mixin&gt;()</code> &ndash; you can also call it with a <code>const char*</code> argument, which will be interpreted as a mixin name.</p>
<p>When being called like this, it will return <code>bool</code>. True if a mixin of this name was found, and false if it wasn't. Note that this true or false value does not give you the information on whether the mixin will be added or removed from the object, but only a mixin of name exists in the domain. As you might remember the mutation rules (if such are added) will determine whether the mixin is actually added an removed.</p>
<div class="fragment"><div class="line"><a class="code" href="classdynamix_1_1object__type__template.html">dynamix::object_type_template</a> tmpl;</div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;num_mixins; ++i)</div><div class="line">{</div><div class="line">    getline(in, line);</div><div class="line">    tmpl.add(line.c_str());</div><div class="line">}</div><div class="line">tmpl.create();</div></div><!-- fragment --><p> Now what's left is to apply the template to the object:</p>
<div class="fragment"><div class="line">tmpl.apply_to(obj);</div></div><!-- fragment --><p> The last thing we need to do when loading an object is to load the data within its mixins. The object is created with the appropriate mixins, so let's call the <code>load</code> multicast message.</p>
<div class="fragment"><div class="line">load(obj, in);</div></div><!-- fragment --><p> It should load the data correctly because the order of the save and load execution is the same &ndash; determined by their priority.</p>
<h1><a class="anchor" id="impl_notes"></a>
Implementation notes </h1>
<p>Here are some explanations that may help you make sense of the code of the library if you need to read it:</p>
<p>The overall structure of the library is based on a main class called <code>domain</code> which holds all registered mixins and messages, and keeps the type registry.</p>
<h2><a class="anchor" id="registration"></a>
Mixin and feature registration </h2>
<p>The <code>DYNAMIX_DEFINE_MIXIN</code> macro instantiates a class that is similar to a metafunction, as its only purpose is to globally instantiate itself, which in turn will lead to <code>domain::register_mixin_type</code> being called.</p>
<p>It also generates a function that registers the mixin features.</p>
<p><code>domain::register_mixin_type</code> is a template method and it will appropriately fill a structure, containing the mixin type information &ndash; name, constructor, destructor, id &ndash; and will also call the generated function that registers its features.</p>
<p>The feature registration is composed of two parts: one global - to introduce the feature to the domain, and local called for the specific mixin type being registered. This means that a feature is globally registered multiple times - once for each of its uses for a mixin type. The first of those times will give it an id and fill the feature information structure appropriately. The other global registrations of a feature will see that it has a valid id, and will simply skip the rest of the code.</p>
<p>The local feature registration is performed by the class <code>feature_parser</code> that has overloads for the supported mixin features: currently messages and allocators. The allocator registration is simple. It just sets the allocator member in the mixin type information structure to the appropriate value.</p>
<p>The message registration generates a caller function, based on the specific mixin. This caller function is a specific instantiation of a template function which is generated by the message declaration macros. Its template parameters are the mixin type and the actual member function in the mixin. The caller is then cast to <code>void (*)()</code> to be stored in a vector in the mixin type information structure along with the caller functions for all of its messages.</p>
<p>This process of creating a caller function is based on the article <a href="http://www.codeproject.com/Articles/11015/The-Impossibly-Fast-C-Delegates">The Impossibly Fast C++ Delegates</a> by Sergey Ryazanov.</p>
<h2><a class="anchor" id="mix_msg_ids"></a>
Mixin and message id-s </h2>
<p>Each newly registered mixin and message get an id. The id-s are consecutive indexes in arrays (of <code>mixin_type_info</code> and <code>message_t</code> respectively) in the domain. Thus getting the information for a mixin or a message through its id is a O(1) operation.</p>
<p>The maximum numbers of registered messages and mixins are fixed through the constants <code>DYNAMIX_MAX_MIXINS</code> and <code>DYNAMIX_MAX_MESSAGES</code> in <code><a class="el" href="config_8hpp.html">config.hpp</a></code>.</p>
<p>This allows us to have fixed-size arrays for both in the domain and per object type.</p>
<h2><a class="anchor" id="mut_type_info"></a>
Mutation and type information </h2>
<p>A new object type is initially identified via a bitset per mixin. The domain contains an unordered (hash) map where the key is such a bitset, and the value is an object type info.</p>
<p>The object type info consists of such a bitset (to mark which mixins are available in this type), a compact vector of mixin type information structures a cross indexing array (to indicate which mixin data is at which position in the compact array), and a call table.</p>
<p>The call table plays the same role as the virtual table in C++. It's a fixed size array for every message with non-null values for the messages that are implemented by that type. An element of that array is of type <code>call_table_entry</code>. This is a union that, based on whether the message is a unicast or a multicast, will contain the message data or a begin and an end for a buffer or message datas.</p>
<p>When a type is requested for an object, first it's checked whether such a combination of mixins is an existing type. If not a new object type is created. This fills the mixin information bitset, vector and cross indexing array and then fills the call table. It will allocate a single buffer for all multicast messages within that type. When filling the call table the type creation process will choose the top priority unicast messages and sort the multicasts by priority. It will throw an exception if same-priority unicasts exist.</p>
<p>After the type is available the object data needs to be filled. The object consists of a pointer to its type and an array of the structure <code>mixin_data_in_object</code>. This structure wraps a simple buffer that contains the mixin instance and a pointer to the owning object right in front of it. This is required for the need to get the owning object from within the code of the mixin class (made through <code>dm_this</code> or <code>object_of</code>). Thus, getting the owning object from the mixin is an offset from the <code>this</code> pointer.</p>
<h2><a class="anchor" id="calling_msgs"></a>
Calling messages </h2>
<p>The message calling happens through the message functions which are generated by the message declaration macros.</p>
<p>The call consists of the following steps:</p>
<ul>
<li>Get the message info through a function generated by the message definition macro</li>
<li>Get the call table entry for this message from the object's type</li>
<li>Get the mixin info and the caller function from the call table entry</li>
<li>Get the mixin pointer from the object, based on the mixin info</li>
<li>Cast the caller function from <code>void (*)()</code> to the appropriate signature.</li>
<li>Call the caller function for the mixin pointer.</li>
</ul>
<p>For multicasts there is a <code>for</code> loop for the last four steps.</p>
<h1><a class="anchor" id="why_macros"></a>
Macros rationale </h1>
<p>Many people, upon seeing DynaMix for the first time, have expressed a concern with the seemingly excessive amount of macros the library's users are required to write.</p>
<h2><a class="anchor" id="why_mixin_macros"></a>
Mixin definition and declaration macros </h2>
<p>The mixin definition and declaration macros are often mentioned as easy to remove, and indeed there is a way to reproduce almost all of their functionality without any macros. However not all of it can be reproduced.</p>
<p>One of the key features those macros provide is the global instantiation. Without them, the users will be required to provide explicit entry points for their subsystems and dynamic libraries, where they will have to call some mixin initialization functions. This is not as simple as it sounds. Here is a list of downsides that such explicit entry points may introduce:</p>
<ul>
<li>They will be compilation dependency "focal points": All mixins classes introduced by a subsystem would need to be visible from there, which means recompilations on every change, and more maintenance for the code.</li>
<li>The users will have to be extra careful not to add mixins to objects before their initialization is called.</li>
<li>Duplicated instances of the mixin data structures will exist in different modules (executable and dynamic libraries). In order to deal with this, the domain would need to store multiple copies of info for the same mixin. This will add a small runtime cost to the message calls and mutations.</li>
</ul>
<h2><a class="anchor" id="why_msg_macros"></a>
Message definition and declaration macros </h2>
<p>The message macros are most likely impossible to remove. Unlike the mixin ones, each of them generates many lines of code. More than a hundred.</p>
<p>Probably the only way to remove them completely, would be to make the message calls by string. This will cause the calls to make hash table look-ups (or worse) and will prohibitively slow them down. Such a scenario will also reflect on the way mixins are registerd. The mixin messages would have to be set through something that resembles <code>std::bind</code> adding yet more complexity to the user code.</p>
<h2><a class="anchor" id="external_moc"></a>
External custom preprocessor </h2>
<p>Is is possible (and probably part of the future of the library) to create an external tool that makes the user code a bit nicer. It would resemble <a href="http://qt-project.org/doc/qt-4.8/moc.html">The Meta-Object Compiler of Qt</a>, and similarly, would require a custom preprocessing step of the users' code.</p>
<p>Such a tool could theoretically solve more of the library's problems, like the need to call <code>message(object)</code> instead of <code>object.message()</code> at the very least, and many more...</p>
<p>Still, such an approach also has many opponents, as the code you write when you use it becomes effectively not-C++, but something that can be called a C++ dialect. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Nov 11 2018 10:50:39 for DynaMix by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
