---
title: Home
layout: home
---

# DynaMix

> The legacy documentation for DynaMix v1 can be found [here](v1/).

*WiP documentation for v2*

DynaMix is a library which allows the composition and modification of polymorphic objects at run time. Objects are constructed from building blocks called "mixins" enabling an effect similar to multiple inheritance, while allowing the client code to remain oblivious to the actual composition of the objects.

A take on the [Composition over inheritance](http://en.wikipedia.org/wiki/Composition_over_inheritance) technique, the result resembles the [mixins in Ruby](http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_modules.html). It can also be compared to the [inheritance in Eiffel](http://archive.eiffel.com/doc/online/eiffel50/intro/language/tutorial-10.html)
or the traits in [Self](http://selflanguage.org/_static/tutorial/Language/Prototypes/Organizing.html), [Scala](http://www.scala-lang.org/node/126), [PHP](http://php.net/manual/en/language.oop5.traits.php), [and many others](https://en.wikipedia.org/wiki/Trait_(computer_programming)), or the [roles in Perl](http://doc.perl6.org/language/objects#Roles).

This is given while also having full abstraction between the interface and the definition of types &ndash; a problem often given as the motivation for the [PIMPL idiom](http://www.drdobbs.com/cpp/making-pimpl-easy/205918714).

In short, *DynaMix is an alternative way to accomplish polymorphism*. It is a means to create a project's *architecture*, rather than implement its purpose.

The library uses the type `dynamix::object` as a placeholder, whose instances can be extended with existing classes (mixins), thus providing a particular instance with the features of all those types. Accessing the newly formed type's interface is msot often made through messages &ndash; stand-alone functions generated by the library, which can be thought of as methods.

## Basic Examlpe

Here is a very small and incomplete example of what code may look like with DynaMix:

```c++
    // assuming my_objects.get_ally(0); is a way to get an ally to the
    // main character in a game
    dynamix::object& obj = my_objects.get_ally(0);

    // now let's make the object think some positive thoughts about the
    // main character

    think(obj); // C++ doesn't allow us to have obj.think().
                // DynaMix's messages are standalone functions

    // object composition
    dynamix::mutate(obj)
        .add<flying_creature>();

    // object can now respond to fly()

    fly(obj); // ...instead of obj.fly()

    // object mutation
    dynamix::mutate(obj)
        .remove<ally>()
        .add<enemy>();

    think(obj); // the same object now thinks negative thoughts about the main
                // character, since it's no longer an ally, but an enemy
```

For more detailed, working examples see the tutorials and examples.

## List of features

- Compose objects from mixins at run time
- Physically separate interface and implementation
- Non-intrusive &ndash; mixins don't need to have a common parent or any special code inside
- Mutate "live" objects by changing their composition at run time
- Use `std::polymorphic_allocator` to allow fine-tuning allocations and achieving cache-locality in critical parts of the code
- Create shared libraries and plugins which can enrich or modify objects, without modifying (or even rebuilding) the executable.
- Add "hotswap" to a project while developing
- Messages:
    - Fast polymorphic calls &ndash; comparable to `std::function`
    - Have multicast messages, which are handled by many mixins within an object
    - Thread safe message calls &ndash; as thread safe as the underlying methods.
